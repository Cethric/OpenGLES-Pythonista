# Generated Files. DO NOT EDIT
# Generated on: 09/16/15 08:53:59
import ctypes
from objc_util import *
from GLConstants import *

DEBUG = 1
loaded = [0, 0]

# GLES Constants
GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = 0x00008c29
GL_RGBA16_EXT = 0x0000805b
GL_GLYPH_WIDTH_BIT_NV = 0x00000001
GL_MAX_SAMPLES_NV = 0x00008d57
GL_DST_NV = 0x00009287
GL_OES_packed_depth_stencil = 0x00000001
GL_TEXTURE_TYPE_QCOM = 0x00008bd7
GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT = 0x00009307
GL_UTF8_NV = 0x0000909a
GL_LUMINANCE4_ALPHA4_OES = 0x00008043
GL_R11F_G11F_B10F_APPLE = 0x00008c3a
GL_DRAW_BUFFER0_EXT = 0x00008825
GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES = 0x0000900a
GL_OES_standard_derivatives = 0x00000001
GL_NV_texture_border_clamp = 0x00000001
GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV = 0x00000d36
GL_NV_non_square_matrices = 0x00000001
GL_PERFQUERY_COUNTER_RAW_INTEL = 0x000094f4
GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT = 0x00008e85
GL_NV_fbo_color_attachments = 0x00000001
GL_CONTRAST_NV = 0x000092a1
GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = 0x000093a0
GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = 0x000094fa
GL_EXT_sRGB = 0x00000001
GL_STENCIL_BUFFER_BIT3_QCOM = 0x00080000
GL_HARDLIGHT_KHR = 0x0000929b
GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV = 0x00009347
GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x00008c02
GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES = 0x00008e83
GL_RGBA8_SNORM = 0x00008f97
GL_COMPRESSED_RGBA_ASTC_10x10_KHR = 0x000093bb
GL_DRAW_BUFFER14_EXT = 0x00008833
GL_RGB32F_EXT = 0x00008815
GL_PERFQUERY_COUNTER_EVENT_INTEL = 0x000094f0
GL_DISJOINT_NV = 0x00009283
GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES = 0x00008d68
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = 0x00009632
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x000093d6
GL_EXT_multisampled_render_to_texture = 0x00000001
GL_SHADER_BINARY_DMP = 0x00009250
GL_PATH_GEN_MODE_NV = 0x000090b0
GL_PRIMITIVE_BOUNDING_BOX_EXT = 0x000092be
GL_PATH_ERROR_POSITION_NV = 0x000090ab
GL_PERFMON_GLOBAL_MODE_QCOM = 0x00008fa0
GL_COLOR_ATTACHMENT1_EXT = 0x00008ce1
GL_COMPRESSED_RGBA_ASTC_6x5_KHR = 0x000093b3
GL_RELATIVE_LARGE_CW_ARC_TO_NV = 0x00000019
GL_DRAW_BUFFER13_NV = 0x00008832
GL_QCOM_tiled_rendering = 0x00000001
GL_TESS_CONTROL_OUTPUT_VERTICES_OES = 0x00008e75
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x000093d1
GL_DRAW_BUFFER6_NV = 0x0000882b
GL_TESS_EVALUATION_SHADER_OES = 0x00008e87
GL_NV_depth_nonlinear = 0x00000001
GL_RASTER_MULTISAMPLE_EXT = 0x00009327
GL_EXT_robustness = 0x00000001
GL_SAMPLER_2D_ARRAY_SHADOW_NV = 0x00008dc4
GL_QUERY_BY_REGION_NO_WAIT_NV = 0x00008e16
GL_CONIC_CURVE_TO_NV = 0x0000001a
GL_EXT_shader_pixel_local_storage = 0x00000001
GL_SMOOTH_CUBIC_CURVE_TO_NV = 0x00000010
GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = 0x00009342
GL_KHR_robustness = 0x00000001
GL_RESET_NOTIFICATION_STRATEGY_KHR = 0x00008256
GL_VERTEX_ARRAY_KHR = 0x00008074
GL_COMPRESSED_RGBA_ASTC_4x4_KHR = 0x000093b0
GL_ANGLE_texture_usage = 0x00000001
GL_TEXTURE_VIEW_NUM_LEVELS_OES = 0x000082dc
GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT = 0x00008e81
GL_LUMINANCE32F_EXT = 0x00008818
GL_PALETTE8_R5_G6_B5_OES = 0x00008b97
GL_DEBUG_TYPE_OTHER_KHR = 0x00008251
GL_OES_compressed_paletted_texture = 0x00000001
GL_OES_vertex_array_object = 0x00000001
GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = 0x000094f5
GL_OES_texture_float_linear = 0x00000001
GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x000088fe
GL_EXT_primitive_bounding_box = 0x00000001
GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x0000910b
GL_PATH_END_CAPS_NV = 0x00009076
GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES = 0x000090d8
GL_DRAW_BUFFER15_NV = 0x00008834
GL_QUADS_OES = 0x00000007
GL_CLAMP_TO_BORDER_OES = 0x0000812d
GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES = 0x00009124
GL_STENCIL_INDEX_OES = 0x00001901
GL_LARGE_CW_ARC_TO_NV = 0x00000018
GL_ACTIVE_PROGRAM_EXT = 0x00008259
GL_EXT_texture_compression_s3tc = 0x00000001
GL_RELATIVE_ROUNDED_RECT2_NV = 0x000000eb
GL_QUERY_RESULT_EXT = 0x00008866
GL_OES_fragment_precision_high = 0x00000001
GL_EXT_multi_draw_arrays = 0x00000001
GL_INT_SAMPLER_BUFFER_OES = 0x00008dd0
GL_SYNC_OBJECT_APPLE = 0x00008a53
GL_DRAW_BUFFER7_EXT = 0x0000882c
GL_LINEARDODGE_NV = 0x000092a4
GL_VERTEX_ARRAY_OBJECT_EXT = 0x00009154
GL_RENDERBUFFER_SAMPLES_NV = 0x00008cab
GL_BOUNDING_BOX_NV = 0x0000908d
GL_ANGLE_depth_texture = 0x00000001
GL_LINES_ADJACENCY_OES = 0x0000000a
GL_OVR_multiview2 = 0x00000001
GL_COVERAGE_COMPONENT_NV = 0x00008ed0
GL_NV_explicit_attrib_location = 0x00000001
GL_DECODE_EXT = 0x00008a49
GL_COLOR_BUFFER_BIT4_QCOM = 0x00000010
GL_CLIP_DISTANCE5_APPLE = 0x00003005
GL_TEXTURE_FORMAT_QCOM = 0x00008bd6
GL_CONTEXT_RELEASE_BEHAVIOR_KHR = 0x000082fb
GL_MULTISAMPLE_BUFFER_BIT6_QCOM = 0x40000000
GL_RELATIVE_SMALL_CW_ARC_TO_NV = 0x00000015
GL_FONT_X_MAX_BOUNDS_BIT_NV = 0x00040000
GL_R16F_EXT = 0x0000822d
GL_PERCENTAGE_AMD = 0x00008bc3
GL_GEOMETRY_LINKED_INPUT_TYPE_OES = 0x00008917
GL_STENCIL_INDEX1_OES = 0x00008d46
GL_UNKNOWN_CONTEXT_RESET_KHR = 0x00008255
GL_TEXTURE_DEPTH_QCOM = 0x00008bd4
GL_OES_geometry_point_size = 0x00000001
GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES = 0x00008e8a
GL_VIRTUAL_PAGE_SIZE_Y_EXT = 0x00009196
GL_NV_framebuffer_blit = 0x00000001
GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x00008c01
GL_TRANSLATE_Y_NV = 0x0000908f
GL_BGRA_EXT = 0x000080e1
GL_FRAGMENT_COVERAGE_TO_COLOR_NV = 0x000092dd
GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = 0x00000011
GL_UNSIGNED_INT_IMAGE_BUFFER_OES = 0x00009067
GL_COMPRESSED_RGBA_ASTC_4x4x3_OES = 0x000093c2
GL_FONT_HAS_KERNING_BIT_NV = 0x10000000
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = 0x00008d6c
GL_GEOMETRY_SHADER_EXT = 0x00008dd9
GL_COLOR_ATTACHMENT15_EXT = 0x00008cef
GL_UNDEFINED_VERTEX_EXT = 0x00008260
GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = 0x00009105
GL_FLOAT_MAT2x4_NV = 0x00008b66
GL_PATH_STENCIL_VALUE_MASK_NV = 0x000090b9
GL_ANY_SAMPLES_PASSED_EXT = 0x00008c2f
GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR = 0x00008242
GL_EXT_shader_implicit_conversions = 0x00000001
GL_EXT_occlusion_query_boolean = 0x00000001
GL_MAP_PERSISTENT_BIT_EXT = 0x00000040
GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = 0x000094f2
GL_TIME_ELAPSED_EXT = 0x000088bf
GL_PATH_STENCIL_FUNC_NV = 0x000090b7
GL_BEVEL_NV = 0x000090a6
GL_KHR_debug = 0x00000001
GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = 0x00008a55
GL_SRC_OUT_NV = 0x0000928c
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x000093d8
GL_DRAW_BUFFER9_NV = 0x0000882e
GL_EXT_color_buffer_float = 0x00000001
GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE = 0x00009117
GL_BUFFER_IMMUTABLE_STORAGE_EXT = 0x0000821f
GL_MAX_TESS_PATCH_COMPONENTS_EXT = 0x00008e84
GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES = 0x00008a2c
GL_COVERAGE_MODULATION_NV = 0x00009332
GL_PROGRAM_PIPELINE_BINDING_EXT = 0x0000825a
GL_IMG_program_binary = 0x00000001
GL_ARM_mali_program_binary = 0x00000001
GL_COLOR_ATTACHMENT12_NV = 0x00008cec
GL_TEXTURE_3D_OES = 0x0000806f
GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = 0x00009343
GL_BLEND_PREMULTIPLIED_SRC_NV = 0x00009280
GL_READ_FRAMEBUFFER_NV = 0x00008ca8
GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = 0x00008fb3
GL_R16_EXT = 0x0000822a
GL_BUFFER_KHR = 0x000082e0
GL_MAX_SAMPLES_IMG = 0x00009135
GL_TESS_GEN_SPACING_EXT = 0x00008e77
GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = 0x00000010
GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES = 0x00008da8
GL_TESS_CONTROL_SHADER_EXT = 0x00008e88
GL_FENCE_CONDITION_NV = 0x000084f4
GL_SAMPLER_2D_SHADOW_EXT = 0x00008b62
GL_NO_RESET_NOTIFICATION_KHR = 0x00008261
GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES = 0x0000886c
GL_MULTISAMPLE_BUFFER_BIT5_QCOM = 0x20000000
GL_OVR_multiview = 0x00000001
GL_OES_compressed_ETC1_RGB8_texture = 0x00000001
GL_PALETTE4_R5_G6_B5_OES = 0x00008b92
GL_CONTEXT_LOST_KHR = 0x00000507
GL_OES_copy_image = 0x00000001
GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES = 0x00008918
GL_QCOM_extended_get2 = 0x00000001
GL_PATH_COMMAND_COUNT_NV = 0x0000909d
GL_STACK_UNDERFLOW_KHR = 0x00000504
GL_DEBUG_GROUP_STACK_DEPTH_KHR = 0x0000826d
GL_TEXTURE_IMMUTABLE_LEVELS = 0x000082df
GL_PATH_INITIAL_END_CAP_NV = 0x00009077
GL_DRAW_BUFFER11_NV = 0x00008830
GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT = 0x000092cf
GL_OES_shader_multisample_interpolation = 0x00000001
GL_EXT_shadow_samplers = 0x00000001
GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x00008e1e
GL_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0000000e
GL_3DC_XY_AMD = 0x000087fa
GL_RELATIVE_QUADRATIC_CURVE_TO_NV = 0x0000000b
GL_NV_viewport_array = 0x00000001
GL_DIFFERENCE_KHR = 0x0000929e
GL_ALPHA8_EXT = 0x0000803c
GL_EXT_separate_shader_objects = 0x00000001
GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES = 0x00009307
GL_COLORBURN_KHR = 0x0000929a
GL_POINT_NV = 0x00001b00
GL_PALETTE8_RGB8_OES = 0x00008b95
GL_ROUND_NV = 0x000090a4
GL_MAX_FRAMEBUFFER_LAYERS_EXT = 0x00009317
GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = 0x00008d56
GL_DEPTH_BUFFER_BIT5_QCOM = 0x00002000
GL_RELATIVE_MOVE_TO_NV = 0x00000003
GL_SMAPHS30_PROGRAM_BINARY_DMP = 0x00009251
GL_R32F_EXT = 0x0000822e
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x000093d9
GL_VIEWPORT_SUBPIXEL_BITS_NV = 0x0000825c
GL_OES_draw_buffers_indexed = 0x00000001
GL_DRAW_BUFFER8_EXT = 0x0000882d
GL_POLYGON_OFFSET_LINE_NV = 0x00002a02
GL_SUPERSAMPLE_SCALE_Y_NV = 0x00009373
GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x00008210
GL_RENDERBUFFER_SAMPLES_APPLE = 0x00008cab
GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = 0x00008f63
GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES = 0x00008e86
GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE = 0x00008c3b
GL_OES_sample_variables = 0x00000001
GL_TEXTURE_BORDER_COLOR_NV = 0x00001004
GL_SKIP_MISSING_GLYPH_NV = 0x000090a9
GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT = 0x00009199
GL_IMG_texture_compression_pvrtc2 = 0x00000001
GL_COLOR_ATTACHMENT_EXT = 0x000090f0
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x000093dd
GL_FLOAT_MAT3x4_NV = 0x00008b68
GL_OBJECT_TYPE_APPLE = 0x00009112
GL_PATH_COMPUTED_LENGTH_NV = 0x000090a0
GL_DEBUG_TYPE_PUSH_GROUP_KHR = 0x00008269
GL_QUERY_OBJECT_EXT = 0x00009153
GL_STENCIL_BUFFER_BIT5_QCOM = 0x00200000
GL_PALETTE8_RGBA4_OES = 0x00008b98
GL_TRANSPOSE_AFFINE_2D_NV = 0x00009096
GL_MOVE_TO_NV = 0x00000002
GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x00008e5c
GL_TEXTURE_VIEW_NUM_LAYERS_OES = 0x000082de
GL_NV_conditional_render = 0x00000001
GL_TEXTURE_VIEW_NUM_LAYERS_EXT = 0x000082de
GL_MAX_TESS_GEN_LEVEL_OES = 0x00008e7e
GL_ANGLE_framebuffer_multisample = 0x00000001
GL_IS_PER_PATCH_EXT = 0x000092e7
GL_COLOR_ATTACHMENT9_EXT = 0x00008ce9
GL_LINE_STRIP_ADJACENCY_EXT = 0x0000000b
GL_PROGRAM_BINARY_FORMATS_OES = 0x000087ff
GL_QCOM_binning_control = 0x00000001
GL_COLOR_ATTACHMENT11_EXT = 0x00008ceb
GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT = 0x000092d5
GL_TESS_CONTROL_SHADER_BIT_EXT = 0x00000008
GL_EXT_copy_image = 0x00000001
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x000093d7
GL_COVERAGE_EDGE_FRAGMENTS_NV = 0x00008ed6
GL_PATH_PROJECTION_STACK_DEPTH_NV = 0x00000ba4
GL_AMD_compressed_3DC_texture = 0x00000001
GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x00008e7f
GL_RGB8_OES = 0x00008051
GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT = 0x00009124
GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x0000910d
GL_MAP_FLUSH_EXPLICIT_BIT_EXT = 0x00000010
GL_FILE_NAME_NV = 0x00009074
GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV = 0x00009330
GL_COUNTER_RANGE_AMD = 0x00008bc1
GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = 0x00008de1
GL_COLOR_ATTACHMENT4_EXT = 0x00008ce4
GL_STENCIL_INDEX8_OES = 0x00008d48
GL_COLOR_ATTACHMENT13_EXT = 0x00008ced
GL_COLOR_ATTACHMENT14_NV = 0x00008cee
GL_TEXTURE_BORDER_COLOR_EXT = 0x00001004
GL_MAP_WRITE_BIT = 0x00000002
GL_COMPRESSED_RGBA_ASTC_6x6x5_OES = 0x000093c8
GL_NV_image_formats = 0x00000001
GL_ISOLINES_EXT = 0x00008e7a
GL_MAX_DRAW_BUFFERS_NV = 0x00008824
GL_COLOR_ATTACHMENT6_NV = 0x00008ce6
GL_AMD_performance_monitor = 0x00000001
GL_MAX_TEXTURE_BUFFER_SIZE_OES = 0x00008c2b
GL_LUMINANCE_ALPHA32F_EXT = 0x00008819
GL_FONT_UNINTELLIGIBLE_NV = 0x0000936b
GL_GREEN_NV = 0x00001904
GL_ALL_SHADER_BITS_EXT = 0xffffffff
GL_PATH_PROJECTION_MATRIX_NV = 0x00000ba7
GL_SLUMINANCE_ALPHA_NV = 0x00008c44
GL_EXT_YUV_target = 0x00000001
GL_SAMPLER_KHR = 0x000082e6
GL_EXT_multiview_draw_buffers = 0x00000001
GL_UNSIGNED_NORMALIZED_EXT = 0x00008c17
GL_TRIANGLES_ADJACENCY_EXT = 0x0000000c
GL_DEBUG_SOURCE_THIRD_PARTY_KHR = 0x00008249
GL_RGBA16_SNORM_EXT = 0x00008f9b
GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT = 0x00009308
GL_EXT_shader_integer_mix = 0x00000001
GL_NV_copy_buffer = 0x00000001
GL_MINUS_NV = 0x0000929f
GL_EXT_texture_norm16 = 0x00000001
GL_DYNAMIC_STORAGE_BIT_EXT = 0x00000100
GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT = 0x00008366
GL_DEPTH_COMPONENT32_OES = 0x000081a7
GL_DRAW_BUFFER8_NV = 0x0000882d
GL_ANGLE_framebuffer_blit = 0x00000001
GL_SAMPLE_ALPHA_TO_ONE_EXT = 0x0000809f
GL_TEXTURE_VIEW_MIN_LAYER_OES = 0x000082dd
GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT = 0x00008918
GL_CLIP_DISTANCE4_APPLE = 0x00003004
GL_COLOR_BUFFER_BIT0_QCOM = 0x00000001
GL_TIMEOUT_EXPIRED_APPLE = 0x0000911b
GL_UNSIGNED_INT_2_10_10_10_REV_EXT = 0x00008368
GL_COVERAGE_MODULATION_TABLE_NV = 0x00009331
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x000093d3
GL_ATC_RGB_AMD = 0x00008c92
GL_NV_read_buffer = 0x00000001
GL_NV_generate_mipmap_sRGB = 0x00000001
GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = 0x00009340
GL_MAX_DRAW_BUFFERS_EXT = 0x00008824
GL_CONJOINT_NV = 0x00009284
GL_Z400_BINARY_AMD = 0x00008740
GL_OES_EGL_image_external_essl3 = 0x00000001
GL_STENCIL_EXT = 0x00001802
GL_EXT_texture_type_2_10_10_10_REV = 0x00000001
GL_RELATIVE_SMALL_CCW_ARC_TO_NV = 0x00000013
GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = 0x0000826c
GL_PERFMON_RESULT_SIZE_AMD = 0x00008bc5
GL_ETC1_SRGB8_NV = 0x000088ee
GL_SHADER_BINARY_VIV = 0x00008fc4
GL_RELATIVE_CUBIC_CURVE_TO_NV = 0x0000000d
GL_FLOAT_MAT4x3_NV = 0x00008b6a
GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD = 0x000087ee
GL_DEPTH_SAMPLES_NV = 0x0000932d
GL_PRIMITIVES_GENERATED_EXT = 0x00008c87
GL_DEPTH_STENCIL_OES = 0x000084f9
GL_IMAGE_BUFFER_EXT = 0x00009051
GL_ATC_RGBA_EXPLICIT_ALPHA_AMD = 0x00008c93
GL_EXT_texture_buffer = 0x00000001
GL_FLOAT_MAT2x3_NV = 0x00008b65
GL_FONT_HEIGHT_BIT_NV = 0x00800000
GL_SRGB8_ALPHA8_EXT = 0x00008c43
GL_HSL_COLOR_KHR = 0x000092af
GL_INT_10_10_10_2_OES = 0x00008df7
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = 0x000093e3
GL_STACK_OVERFLOW_KHR = 0x00000503
GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES = 0x000090d9
GL_MULTIPLY_KHR = 0x00009294
GL_NV_fragment_coverage_to_color = 0x00000001
GL_NV_fence = 0x00000001
GL_PATH_STROKE_WIDTH_NV = 0x00009075
GL_SMALL_CW_ARC_TO_NV = 0x00000014
GL_DEBUG_SEVERITY_NOTIFICATION_KHR = 0x0000826b
GL_DST_OVER_NV = 0x00009289
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x000093dc
GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = 0x00008dd8
GL_TEXTURE_BUFFER_SIZE_EXT = 0x0000919e
GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = 0x00008c2d
GL_TESS_GEN_VERTEX_ORDER_EXT = 0x00008e78
GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT = 0x00009123
GL_COLOR_ATTACHMENT5_NV = 0x00008ce5
GL_RGB_422_APPLE = 0x00008a1f
GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = 0x00009137
GL_CONTEXT_ROBUST_ACCESS_EXT = 0x000090f3
GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV = 0x0000909c
GL_TEXTURE_OBJECT_VALID_QCOM = 0x00008bdb
GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x00008ddf
GL_PATH_DASH_ARRAY_COUNT_NV = 0x0000909f
GL_DRAW_BUFFER_EXT = 0x00000c01
GL_EXT_multisampled_compatibility = 0x00000001
GL_RELATIVE_ROUNDED_RECT_NV = 0x000000e9
GL_MULTISAMPLE_EXT = 0x0000809d
GL_PATCHES_EXT = 0x0000000e
GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT = 0x00008365
GL_TEXTURE_BINDING_EXTERNAL_OES = 0x00008d67
GL_PATH_GEN_COMPONENTS_NV = 0x000090b3
GL_EXT_unpack_subimage = 0x00000001
GL_OVERLAY_KHR = 0x00009296
GL_FRACTIONAL_ODD_OES = 0x00008e7b
GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES = 0x0000919f
GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = 0x00008d6a
GL_MIN = 0x00008007
GL_NV_sample_mask_override_coverage = 0x00000001
GL_TEXTURE_WRAP_R_OES = 0x00008072
GL_EXT_texture_storage = 0x00000001
GL_TEXTURE_NUM_LEVELS_QCOM = 0x00008bd9
GL_APPLE_color_buffer_packed_float = 0x00000001
GL_ANGLE_texture_compression_dxt5 = 0x00000001
GL_QUADS_EXT = 0x00000007
GL_PERFQUERY_WAIT_INTEL = 0x000083fb
GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT = 0x000092d4
GL_CIRCULAR_CW_ARC_TO_NV = 0x000000fa
GL_INNOCENT_CONTEXT_RESET_KHR = 0x00008254
GL_IMG_texture_compression_pvrtc = 0x00000001
GL_DIFFERENCE_NV = 0x0000929e
GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT = 0x000090d8
GL_RED_EXT = 0x00001903
GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = 0x000094fd
GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x000083f0
GL_FJ_shader_binary_GCCSO = 0x00000001
GL_EXT_disjoint_timer_query = 0x00000001
GL_COLORDODGE_NV = 0x00009299
GL_DST_OUT_NV = 0x0000928d
GL_NV_path_rendering_shared_edge = 0x00000001
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = 0x000093e6
GL_NV_conservative_raster = 0x00000001
GL_COVERAGE_MODULATION_TABLE_SIZE_NV = 0x00009333
GL_CUBIC_CURVE_TO_NV = 0x0000000c
GL_TEXTURE_VIEW_MIN_LEVEL_EXT = 0x000082db
GL_ALPHA_TEST_QCOM = 0x00000bc0
GL_XOR_NV = 0x00001506
GL_SAMPLE_LOCATION_NV = 0x00008e50
GL_EXT_geometry_shader = 0x00000001
GL_UNSIGNED_SHORT_8_8_REV_APPLE = 0x000085bb
GL_MAX_TESS_GEN_LEVEL_EXT = 0x00008e7e
GL_MAX_FRAMEBUFFER_LAYERS_OES = 0x00009317
GL_PATH_MODELVIEW_NV = 0x00001700
GL_TEXTURE_BUFFER_OFFSET_EXT = 0x0000919d
GL_FONT_Y_MIN_BOUNDS_BIT_NV = 0x00020000
GL_TEXTURE_WIDTH_QCOM = 0x00008bd2
GL_FONT_UNAVAILABLE_NV = 0x0000936a
GL_FONT_UNITS_PER_EM_BIT_NV = 0x00100000
GL_RG16_EXT = 0x0000822c
GL_OES_texture_npot = 0x00000001
GL_RGB16F_EXT = 0x0000881b
GL_DUP_LAST_CUBIC_CURVE_TO_NV = 0x000000f4
GL_EXT_texture_sRGB_RG8 = 0x00000001
GL_DRAW_BUFFER13_EXT = 0x00008832
GL_MULTISAMPLE_BUFFER_BIT2_QCOM = 0x04000000
GL_IMAGE_CUBE_MAP_ARRAY_OES = 0x00009054
GL_PATH_FORMAT_SVG_NV = 0x00009070
GL_KHR_robust_buffer_access_behavior = 0x00000001
GL_ROUNDED_RECT_NV = 0x000000e8
GL_LUMINANCE8_EXT = 0x00008040
GL_LAYER_PROVOKING_VERTEX_OES = 0x0000825e
GL_FONT_DESCENDER_BIT_NV = 0x00400000
GL_OES_tessellation_shader = 0x00000001
GL_FRAMEBUFFER_DEFAULT_LAYERS_OES = 0x00009312
GL_DEPTH_COMPONENT16_OES = 0x000081a5
GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = 0x00008da8
GL_PATH_STROKE_COVER_MODE_NV = 0x00009083
GL_OES_texture_buffer = 0x00000001
GL_PROGRAM_PIPELINE_KHR = 0x000082e4
GL_EXT_post_depth_coverage = 0x00000001
GL_GEOMETRY_SHADER_BIT_EXT = 0x00000004
GL_ROUNDED_RECT2_NV = 0x000000ea
GL_COLORDODGE_KHR = 0x00009299
GL_OES_get_program_binary = 0x00000001
GL_SUPERSAMPLE_SCALE_X_NV = 0x00009372
GL_MAX_SAMPLES_APPLE = 0x00008d57
GL_APPLE_framebuffer_multisample = 0x00000001
GL_TRANSLATE_3D_NV = 0x00009091
GL_TESS_GEN_VERTEX_ORDER_OES = 0x00008e78
GL_MULTISAMPLE_BUFFER_BIT7_QCOM = 0x80000000
GL_OES_vertex_half_float = 0x00000001
GL_FILL_RECTANGLE_NV = 0x0000933c
GL_FIRST_VERTEX_CONVENTION_EXT = 0x00008e4d
GL_FENCE_STATUS_NV = 0x000084f3
GL_TEXTURE_IMAGE_VALID_QCOM = 0x00008bd8
GL_RG16_SNORM_EXT = 0x00008f99
GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV = 0x0000932f
GL_DEPTH_BUFFER_BIT4_QCOM = 0x00001000
GL_QCOM_alpha_test = 0x00000001
GL_EXT_draw_instanced = 0x00000001
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x000093d4
GL_ADJACENT_PAIRS_NV = 0x000090ae
GL_SGX_PROGRAM_BINARY_IMG = 0x00009130
GL_SRC1_COLOR_EXT = 0x000088f9
GL_FONT_TARGET_UNAVAILABLE_NV = 0x00009369
GL_COMPRESSED_RGBA_ASTC_8x8_KHR = 0x000093b7
GL_TESS_GEN_MODE_EXT = 0x00008e76
GL_RECT_NV = 0x000000f6
GL_DEBUG_OUTPUT_KHR = 0x000092e0
GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT = 0x0000900a
GL_PATH_DASH_CAPS_NV = 0x0000907b
GL_PATH_CLIENT_LENGTH_NV = 0x0000907f
GL_EXT_blend_func_extended = 0x00000001
GL_PATCH_VERTICES_EXT = 0x00008e72
GL_FONT_NUM_GLYPH_INDICES_BIT_NV = 0x20000000
GL_SGX_BINARY_IMG = 0x00008c0a
GL_DRAW_BUFFER3_NV = 0x00008828
GL_KHR_texture_compression_astc_hdr = 0x00000001
GL_DEBUG_CALLBACK_USER_PARAM_KHR = 0x00008245
GL_NV_read_depth_stencil = 0x00000001
GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x000084ff
GL_SIGNALED_APPLE = 0x00009119
GL_RGBA8_OES = 0x00008058
GL_KHR_blend_equation_advanced = 0x00000001
GL_MAX_SAMPLES_ANGLE = 0x00008d57
GL_OES_shader_image_atomic = 0x00000001
GL_RELATIVE_CONIC_CURVE_TO_NV = 0x0000001b
GL_COLOR_ATTACHMENT7_NV = 0x00008ce7
GL_EXT_geometry_point_size = 0x00000001
GL_SLUMINANCE8_NV = 0x00008c47
GL_ANGLE_instanced_arrays = 0x00000001
GL_TRIANGLE_STRIP_ADJACENCY_EXT = 0x0000000d
GL_TEXTURE_BUFFER_OES = 0x00008c2a
GL_SHADER_OBJECT_EXT = 0x00008b48
GL_PATH_FILL_BOUNDING_BOX_NV = 0x000090a1
GL_LIGHTEN_NV = 0x00009298
GL_EXT_draw_buffers_indexed = 0x00000001
GL_SCREEN_NV = 0x00009295
GL_PATH_INITIAL_DASH_CAP_NV = 0x0000907c
GL_KHR_no_error = 0x00000001
GL_COLOR_ATTACHMENT11_NV = 0x00008ceb
GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR = 0x00000008
GL_RELATIVE_HORIZONTAL_LINE_TO_NV = 0x00000007
GL_EXT_read_format_bgra = 0x00000001
GL_DRAW_BUFFER10_EXT = 0x0000882f
GL_CIRCULAR_CCW_ARC_TO_NV = 0x000000f8
GL_MULTISAMPLE_BUFFER_BIT1_QCOM = 0x02000000
GL_BUFFER_STORAGE_FLAGS_EXT = 0x00008220
GL_FRACTIONAL_EVEN_EXT = 0x00008e7c
GL_FONT_X_MIN_BOUNDS_BIT_NV = 0x00010000
GL_TEXTURE_IMMUTABLE_FORMAT_EXT = 0x0000912f
GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT = 0x000092ce
GL_FRAGMENT_SHADER_BIT_EXT = 0x00000002
GL_DRAW_FRAMEBUFFER_NV = 0x00008ca9
GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = 0x00008243
GL_LINEARLIGHT_NV = 0x000092a7
GL_MOVE_TO_CONTINUES_NV = 0x000090b6
GL_MAX_3D_TEXTURE_SIZE_OES = 0x00008073
GL_PROGRAM_SEPARABLE_EXT = 0x00008258
GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES = 0x000092d4
GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = 0x0000824e
GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x0000900e
GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV = 0x02000000
GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = 0x00008f66
GL_EXT_shader_io_blocks = 0x00000001
GL_UNPACK_SKIP_PIXELS_EXT = 0x00000cf4
GL_EXT_texture_filter_minmax = 0x00000001
GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT = 0x000090d9
GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT = 0x00008e86
GL_NV_read_stencil = 0x00000001
GL_PATH_MODELVIEW_STACK_DEPTH_NV = 0x00000ba3
GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT = 0x00008be7
GL_BLEND_OVERLAP_NV = 0x00009281
GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x000083f1
GL_COLOR_SAMPLES_NV = 0x00008e20
GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = 0x00008d56
GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = 0x000090be
GL_NV_draw_buffers = 0x00000001
GL_COLOR_ATTACHMENT0_EXT = 0x00008ce0
GL_GEOMETRY_LINKED_VERTICES_OUT_OES = 0x00008916
GL_SRC1_ALPHA_EXT = 0x00008589
GL_PLUS_CLAMPED_NV = 0x000092b1
GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = 0x000082fc
GL_SRGB_EXT = 0x00008c40
GL_NV_polygon_mode = 0x00000001
GL_COMPRESSED_RGBA_ASTC_6x6_KHR = 0x000093b4
GL_FLOAT_MAT3x2_NV = 0x00008b67
GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT = 0x0000886c
GL_RGB565_OES = 0x00008d62
GL_RGB5_A1_OES = 0x00008057
GL_SRGB8_NV = 0x00008c41
GL_MAP_INVALIDATE_BUFFER_BIT_EXT = 0x00000008
GL_GEOMETRY_SHADER_INVOCATIONS_OES = 0x0000887f
GL_DUP_FIRST_CUBIC_CURVE_TO_NV = 0x000000f2
GL_DRAW_FRAMEBUFFER_BINDING_NV = 0x00008ca6
GL_COMPRESSED_RGBA_ASTC_5x5x5_OES = 0x000093c6
GL_BINNING_CONTROL_HINT_QCOM = 0x00008fb0
GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = 0x000090bd
GL_COUNT_UP_NV = 0x00009088
GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES = 0x000092cd
GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = 0x000094fb
GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = 0x00008c4d
GL_VIRTUAL_PAGE_SIZE_INDEX_EXT = 0x000091a7
GL_EXT_blend_minmax = 0x00000001
GL_CLIP_DISTANCE0_APPLE = 0x00003000
GL_TRANSFORM_FEEDBACK = 0x00008e22
GL_SYNC_FLAGS_APPLE = 0x00009115
GL_COLOR_ATTACHMENT1_NV = 0x00008ce1
GL_COLOR_ATTACHMENT15_NV = 0x00008cef
GL_GPU_OPTIMIZED_QCOM = 0x00008fb2
GL_NV_path_rendering = 0x00000001
GL_OES_required_internalformat = 0x00000001
GL_POLYGON_MODE_NV = 0x00000b40
GL_EXT_sRGB_write_control = 0x00000001
GL_HSL_HUE_NV = 0x000092ad
GL_SAMPLER_3D_OES = 0x00008b5f
GL_QCOM_driver_control = 0x00000001
GL_IMAGE_BUFFER_OES = 0x00009051
GL_COLOR_BUFFER_BIT3_QCOM = 0x00000008
GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x00008b8b
GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = 0x00000080
GL_OES_element_index_uint = 0x00000001
GL_RENDERBUFFER_SAMPLES_IMG = 0x00009133
GL_TESS_CONTROL_OUTPUT_VERTICES_EXT = 0x00008e75
GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x00008c03
GL_COMPRESSED_RGBA_ASTC_4x4x4_OES = 0x000093c3
GL_BUFFER_MAP_POINTER_OES = 0x000088bd
GL_MAX_SAMPLES_EXT = 0x00008d57
GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x0000900f
GL_MAX_PATCH_VERTICES_OES = 0x00008e7d
GL_MOVE_TO_RESETS_NV = 0x000090b5
GL_HSL_HUE_KHR = 0x000092ad
GL_IMAGE_CUBE_MAP_ARRAY_EXT = 0x00009054
GL_IMG_multisampled_render_to_texture = 0x00000001
GL_BUFFER_MAPPED_OES = 0x000088bc
GL_COMPRESSED_RGBA_ASTC_8x6_KHR = 0x000093b6
GL_BLEND_ADVANCED_COHERENT_KHR = 0x00009285
GL_TEXTURE_SRGB_DECODE_EXT = 0x00008a48
GL_EXCLUSION_KHR = 0x000092a0
GL_HALF_FLOAT_OES = 0x00008d61
GL_MIN_SAMPLE_SHADING_VALUE_OES = 0x00008c37
GL_COMPRESSED_RGBA_ASTC_12x10_KHR = 0x000093bc
GL_SYSTEM_FONT_NAME_NV = 0x00009073
GL_APPLE_copy_texture_levels = 0x00000001
GL_OES_texture_stencil8 = 0x00000001
GL_3DC_X_AMD = 0x000087f9
GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x00008ddf
GL_LINE_TO_NV = 0x00000004
GL_NV_read_depth = 0x00000001
GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = 0x00008da7
GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = 0x000094f8
GL_FILL_NV = 0x00001b02
GL_FRACTIONAL_ODD_EXT = 0x00008e7b
GL_OES_stencil4 = 0x00000001
GL_OES_stencil1 = 0x00000001
GL_GUILTY_CONTEXT_RESET_EXT = 0x00008253
GL_OES_texture_3D = 0x00000001
GL_RELATIVE_ARC_TO_NV = 0x000000ff
GL_UNSIGNALED_APPLE = 0x00009118
GL_DEPTH_BUFFER_BIT3_QCOM = 0x00000800
GL_VIV_shader_binary = 0x00000001
GL_TESS_CONTROL_SHADER_BIT_OES = 0x00000008
GL_SMALL_CCW_ARC_TO_NV = 0x00000012
GL_COLOR_ATTACHMENT6_EXT = 0x00008ce6
GL_DRAW_BUFFER4_EXT = 0x00008829
GL_DMP_PROGRAM_BINARY_DMP = 0x00009253
GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = 0x00008a56
GL_DEBUG_TYPE_ERROR_KHR = 0x0000824c
GL_COLOR_ATTACHMENT9_NV = 0x00008ce9
GL_CIRCULAR_TANGENT_ARC_TO_NV = 0x000000fc
GL_UNSIGNED_INT_SAMPLER_BUFFER_OES = 0x00008dd8
GL_STENCIL_BUFFER_BIT1_QCOM = 0x00020000
GL_COUNTER_TYPE_AMD = 0x00008bc0
GL_READ_FRAMEBUFFER_APPLE = 0x00008ca8
GL_COLOR_ATTACHMENT2_EXT = 0x00008ce2
GL_MAX_PATCH_VERTICES_EXT = 0x00008e7d
GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = 0x0000933e
GL_HORIZONTAL_LINE_TO_NV = 0x00000006
GL_ALPHA8_OES = 0x0000803c
GL_COMPRESSED_RGBA_ASTC_12x12_KHR = 0x000093bd
GL_NV_sRGB_formats = 0x00000001
GL_COMPRESSED_RGBA_ASTC_10x8_KHR = 0x000093ba
GL_RESTART_PATH_NV = 0x000000f0
GL_COLOR_ATTACHMENT7_EXT = 0x00008ce7
GL_PATH_OBJECT_BOUNDING_BOX_NV = 0x0000908a
GL_SYNC_CONDITION_APPLE = 0x00009113
GL_FONT_ASCENDER_BIT_NV = 0x00200000
GL_POLYGON_OFFSET_POINT_NV = 0x00002a01
GL_APPLE_texture_packed_float = 0x00000001
GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT = 0x000090cd
GL_RG_EXT = 0x00008227
GL_MAX_MULTIVIEW_BUFFERS_EXT = 0x000090f2
GL_FRACTIONAL_EVEN_OES = 0x00008e7c
GL_GEOMETRY_LINKED_INPUT_TYPE_EXT = 0x00008917
GL_DEPTH_EXT = 0x00001801
GL_COLOR_EXT = 0x00001800
GL_PATH_COORD_COUNT_NV = 0x0000909e
GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES = 0x0000886d
GL_OES_texture_half_float_linear = 0x00000001
GL_RG8_SNORM = 0x00008f95
GL_SAMPLER_BUFFER_EXT = 0x00008dc2
GL_PROGRAM_PIPELINE_OBJECT_EXT = 0x00008a4f
GL_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x00009102
GL_REFERENCED_BY_GEOMETRY_SHADER_OES = 0x00009309
GL_TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010
GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES = 0x0000900d
GL_EXT_color_buffer_half_float = 0x00000001
GL_NV_viewport_array2 = 0x00000001
GL_COLOR_ATTACHMENT8_EXT = 0x00008ce8
GL_LOSE_CONTEXT_ON_RESET_KHR = 0x00008252
GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = 0x00008d56
GL_COVERAGE_SAMPLES_NV = 0x00008ed4
GL_ARC_TO_NV = 0x000000fe
GL_DMP_program_binary = 0x00000001
GL_COMPRESSED_RGBA_ASTC_3x3x3_OES = 0x000093c0
GL_VERTICAL_LINE_TO_NV = 0x00000008
GL_COLOR_ATTACHMENT10_EXT = 0x00008cea
GL_READ_FRAMEBUFFER_BINDING_APPLE = 0x00008caa
GL_STATE_RESTORE = 0x00008bdc
GL_SKIP_DECODE_EXT = 0x00008a4a
GL_DEBUG_SOURCE_APPLICATION_KHR = 0x0000824a
GL_QUADRATIC_CURVE_TO_NV = 0x0000000a
GL_CPU_OPTIMIZED_QCOM = 0x00008fb1
GL_R16_SNORM_EXT = 0x00008f98
GL_MAX_LABEL_LENGTH_KHR = 0x000082e8
GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV = 0x000084e4
GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = 0x000094fe
GL_BOLD_BIT_NV = 0x00000001
GL_SYNC_FENCE_APPLE = 0x00009116
GL_TEXTURE_BORDER_COLOR_OES = 0x00001004
GL_PATH_TERMINAL_END_CAP_NV = 0x00009078
GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = 0x00008d56
GL_PATH_MODELVIEW_MATRIX_NV = 0x00000ba6
GL_COMPARE_REF_TO_TEXTURE_EXT = 0x0000884e
GL_PROGRAMMABLE_SAMPLE_LOCATION_NV = 0x00009341
GL_DEPTH_BUFFER_BIT6_QCOM = 0x00004000
GL_NV_draw_instanced = 0x00000001
GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = 0x00000001
GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES = 0x00008e85
GL_R8_EXT = 0x00008229
GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x0000906a
GL_TEXTURE_CUBE_MAP_ARRAY_OES = 0x00009009
GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV = 0x00000d38
GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x0000900e
GL_PATCHES_OES = 0x0000000e
GL_OES_fbo_render_mipmap = 0x00000001
GL_DRAW_BUFFER6_EXT = 0x0000882b
GL_TEXTURE_TARGET_QCOM = 0x00008bda
GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = 0x00008a52
GL_VIRTUAL_PAGE_SIZE_Z_EXT = 0x00009197
GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = 0x000094f1
GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0000000f
GL_RG8_EXT = 0x0000822b
GL_NV_fragment_shader_interlock = 0x00000001
GL_EXT_buffer_storage = 0x00000001
GL_FRAMEBUFFER_UNDEFINED_OES = 0x00008219
GL_STENCIL_BUFFER_BIT2_QCOM = 0x00040000
GL_RG32F_EXT = 0x00008230
GL_PATH_FILL_MASK_NV = 0x00009081
GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x0000906a
GL_ONE_MINUS_SRC1_COLOR_EXT = 0x000088fa
GL_TEXTURE_VIEW_MIN_LEVEL_OES = 0x000082db
GL_NV_framebuffer_mixed_samples = 0x00000001
GL_MAX_EXT = 0x00008008
GL_TESS_EVALUATION_SHADER_EXT = 0x00008e87
GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT = 0x00008e82
GL_FRAMEBUFFER_SRGB_EXT = 0x00008db9
GL_GEOMETRY_SHADER_BIT_OES = 0x00000004
GL_COLOR_BUFFER_BIT7_QCOM = 0x00000080
GL_EXT_raster_multisample = 0x00000001
GL_CLIP_DISTANCE7_APPLE = 0x00003007
GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES = 0x000090cc
GL_VIVIDLIGHT_NV = 0x000092a6
GL_VERTEX_ARRAY_BINDING_OES = 0x000085b5
GL_DRAW_BUFFER14_NV = 0x00008833
GL_NV_geometry_shader_passthrough = 0x00000001
GL_INTEL_framebuffer_CMAA = 0x00000001
GL_LUMINANCE_ALPHA16F_EXT = 0x0000881f
GL_EXT_texture_border_clamp = 0x00000001
GL_PROGRAM_OBJECT_EXT = 0x00008b40
GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES = 0x000092d5
GL_EXT_draw_buffers = 0x00000001
GL_PATH_FORMAT_PS_NV = 0x00009071
GL_PRIMITIVE_BOUNDING_BOX_OES = 0x000092be
GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = 0x00009134
GL_SHARED_EDGE_NV = 0x000000c0
GL_STANDARD_FONT_NAME_NV = 0x00009072
GL_NUM_PROGRAM_BINARY_FORMATS_OES = 0x000087fe
GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE = 0x000083f3
GL_BLUE_NV = 0x00001905
GL_FONT_Y_MAX_BOUNDS_BIT_NV = 0x00080000
GL_MAX_CLIP_DISTANCES_APPLE = 0x00000d32
GL_OES_texture_view = 0x00000001
GL_PALETTE4_RGBA4_OES = 0x00008b93
GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT = 0x000090cb
GL_CONVEX_HULL_NV = 0x0000908b
GL_FIRST_TO_REST_NV = 0x000090af
GL_COVERAGE_AUTOMATIC_NV = 0x00008ed7
GL_RELATIVE_VERTICAL_LINE_TO_NV = 0x00000009
GL_SR8_EXT = 0x00008fbd
GL_EXT_tessellation_point_size = 0x00000001
GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = 0x00008247
GL_USE_MISSING_GLYPH_NV = 0x000090aa
GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT = 0x000090d7
GL_GLYPH_HAS_KERNING_BIT_NV = 0x00000100
GL_PATCH_VERTICES_OES = 0x00008e72
GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = 0x000094ff
GL_EXT_base_instance = 0x00000001
GL_EXT_texture_view = 0x00000001
GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV = 0x0000825f
GL_NUM_VIRTUAL_PAGE_SIZES_EXT = 0x000091a8
GL_SAMPLE_SHADING_OES = 0x00008c36
GL_PLUS_DARKER_NV = 0x00009292
GL_TEXTURE_2D_MULTISAMPLE = 0x00009100
GL_HSL_LUMINOSITY_KHR = 0x000092b0
GL_ITALIC_BIT_NV = 0x00000002
GL_ANGLE_pack_reverse_row_order = 0x00000001
GL_VIRTUAL_PAGE_SIZE_X_EXT = 0x00009195
GL_DEPTH_BUFFER_BIT2_QCOM = 0x00000400
GL_TRIANGULAR_NV = 0x000090a5
GL_TESS_GEN_SPACING_OES = 0x00008e77
GL_GUILTY_CONTEXT_RESET_KHR = 0x00008253
GL_R8_SNORM = 0x00008f94
GL_COMPRESSED_RGBA_ASTC_8x5_KHR = 0x000093b5
GL_QUERY_KHR = 0x000082e3
GL_QCOM_writeonly_rendering = 0x00000001
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = 0x000093e2
GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES = 0x00008e81
GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT = 0x00008a2c
GL_DST_IN_NV = 0x0000928b
GL_INTEL_performance_query = 0x00000001
GL_COMPRESSED_RGBA_ASTC_6x6x6_OES = 0x000093c9
GL_RENDERBUFFER_SAMPLES_EXT = 0x00008cab
GL_COLORBURN_NV = 0x0000929a
GL_TEXTURE_BUFFER_EXT = 0x00008c2a
GL_PALETTE8_RGB5_A1_OES = 0x00008b99
GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES = 0x000090cb
GL_GEOMETRY_SHADER_OES = 0x00008dd9
GL_STENCIL_BUFFER_BIT0_QCOM = 0x00010000
GL_PALETTE8_RGBA8_OES = 0x00008b96
GL_EXT_sparse_texture = 0x00000001
GL_MAX_COLOR_ATTACHMENTS_EXT = 0x00008cdf
GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES = 0x00008221
GL_UNSIGNED_INT_IMAGE_BUFFER_EXT = 0x00009067
GL_SYNC_STATUS_APPLE = 0x00009114
GL_INVERT_OVG_NV = 0x000092b4
GL_VERTEX_SHADER_BIT_EXT = 0x00000001
GL_COMPRESSED_RGBA_ASTC_5x4x4_OES = 0x000093c4
GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG = 0x000093f0
GL_RESET_NOTIFICATION_STRATEGY_EXT = 0x00008256
GL_UNSIGNED_INT_24_8_OES = 0x000084fa
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x000093d0
GL_FRAGMENT_INPUT_NV = 0x0000936d
GL_COMPRESSED_RGBA_ASTC_10x5_KHR = 0x000093b8
GL_OES_texture_border_clamp = 0x00000001
GL_RGB10_A2_EXT = 0x00008059
GL_QUERY_COUNTER_BITS_EXT = 0x00008864
GL_DEPTH_BUFFER_BIT1_QCOM = 0x00000200
GL_MAX_COLOR_ATTACHMENTS_NV = 0x00008cdf
GL_TEXTURE_COMPARE_MODE_EXT = 0x0000884c
GL_TEXTURE_SAMPLES_IMG = 0x00009136
GL_STANDARD_FONT_FORMAT_NV = 0x0000936c
GL_PATH_TERMINAL_DASH_CAP_NV = 0x0000907d
GL_HSL_LUMINOSITY_NV = 0x000092b0
GL_LUMINANCE8_ALPHA8_OES = 0x00008045
GL_SRC_NV = 0x00009286
GL_UNSIGNED_INT_10_10_10_2_OES = 0x00008df6
GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x00008e1f
GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x000083f2
GL_READ_FRAMEBUFFER_BINDING_ANGLE = 0x00008caa
GL_DEPTH_COMPONENT16_NONLINEAR_NV = 0x00008e2c
GL_RGB10_EXT = 0x00008052
GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x0000910c
GL_IMG_shader_binary = 0x00000001
GL_PROGRAM_KHR = 0x000082e2
GL_PATH_DASH_OFFSET_NV = 0x0000907e
GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT = 0x0000900d
GL_SLUMINANCE_NV = 0x00008c46
GL_EXT_draw_elements_base_vertex = 0x00000001
GL_OES_depth32 = 0x00000001
GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT = 0x0000919f
GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV = 0x01000000
GL_STENCIL_INDEX4_OES = 0x00008d47
GL_SRG8_EXT = 0x00008fbe
GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT = 0x000090cc
GL_COVERAGE_BUFFERS_NV = 0x00008ed3
GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = 0x000088fe
GL_EXT_multi_draw_indirect = 0x00000001
GL_ARM_shader_framebuffer_fetch = 0x00000001
GL_UNSIGNED_INT_5_9_9_9_REV_APPLE = 0x00008c3e
GL_CLAMP_TO_BORDER_NV = 0x0000812d
GL_LARGE_CCW_ARC_TO_NV = 0x00000016
GL_OES_texture_storage_multisample_2d_array = 0x00000001
GL_WRITEONLY_RENDERING_QCOM = 0x00008823
GL_COMPRESSED_RGBA_ASTC_10x6_KHR = 0x000093b9
GL_COLOR_ATTACHMENT12_EXT = 0x00008cec
GL_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x0000900c
GL_OES_vertex_type_10_10_10_2 = 0x00000001
GL_COVERAGE_COMPONENT4_NV = 0x00008ed1
GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x00008e80
GL_EXT_texture_sRGB_decode = 0x00000001
GL_NV_texture_npot_2D_mipmap = 0x00000001
GL_DRAW_BUFFER1_NV = 0x00008826
GL_MAX_DEBUG_MESSAGE_LENGTH_KHR = 0x00009143
GL_SRC_IN_NV = 0x0000928a
GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES = 0x00008c2d
GL_PATH_PROJECTION_NV = 0x00001701
GL_MAX_VIEWPORTS_NV = 0x0000825b
GL_DEBUG_CALLBACK_FUNCTION_KHR = 0x00008244
GL_COLOR_BUFFER_BIT5_QCOM = 0x00000020
GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES = 0x00009308
GL_EXT_debug_label = 0x00000001
GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES = 0x00008de0
GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x0000900f
GL_NV_sample_locations = 0x00000001
GL_SAMPLER_EXTERNAL_OES = 0x00008d66
GL_RELATIVE_ROUNDED_RECT8_NV = 0x000000ef
GL_UNCORRELATED_NV = 0x00009282
GL_NV_internalformat_sample_query = 0x00000001
GL_STENCIL_BUFFER_BIT6_QCOM = 0x00400000
GL_PATH_FILL_COVER_MODE_NV = 0x00009082
GL_DRAW_BUFFER12_EXT = 0x00008831
GL_UNPACK_ROW_LENGTH_EXT = 0x00000cf2
GL_QUERY_NO_WAIT_NV = 0x00008e14
GL_RED_NV = 0x00001903
GL_COLOR_ATTACHMENT3_NV = 0x00008ce3
GL_OES_gpu_shader5 = 0x00000001
GL_DRAW_BUFFER15_EXT = 0x00008834
GL_FIRST_VERTEX_CONVENTION_OES = 0x00008e4d
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = 0x000093e5
GL_RGB9_E5_APPLE = 0x00008c3d
GL_DRAW_FRAMEBUFFER_ANGLE = 0x00008ca9
GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES = 0x00008e82
GL_COVERAGE_BUFFER_BIT_NV = 0x00008000
GL_LAST_VERTEX_CONVENTION_EXT = 0x00008e4e
GL_LINES_ADJACENCY_EXT = 0x0000000a
GL_PALETTE4_RGB8_OES = 0x00008b90
GL_TRIANGLES_ADJACENCY_OES = 0x0000000c
GL_REFERENCED_BY_GEOMETRY_SHADER_EXT = 0x00009309
GL_CLIP_DISTANCE6_APPLE = 0x00003006
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = 0x000093e1
GL_DRAW_BUFFER4_NV = 0x00008829
GL_MAX_TEXTURE_BUFFER_SIZE_EXT = 0x00008c2b
GL_OES_mapbuffer = 0x00000001
GL_EXT_texture_cube_map_array = 0x00000001
GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES = 0x00008da7
GL_COLOR_ATTACHMENT13_NV = 0x00008ced
GL_COUNT_DOWN_NV = 0x00009089
GL_CLIP_DISTANCE3_APPLE = 0x00003003
GL_EXT_tessellation_shader = 0x00000001
GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x000083f3
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = 0x000093e0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = 0x00008cd4
GL_DARKEN_NV = 0x00009297
GL_AFFINE_3D_NV = 0x00009094
GL_EXT_discard_framebuffer = 0x00000001
GL_RELATIVE_LINE_TO_NV = 0x00000005
GL_LAYER_PROVOKING_VERTEX_EXT = 0x0000825e
GL_SLUMINANCE8_ALPHA8_NV = 0x00008c45
GL_RGBA16F_EXT = 0x0000881a
GL_QUERY_RESULT_AVAILABLE_EXT = 0x00008867
GL_RGBA4_OES = 0x00008056
GL_OES_draw_elements_base_vertex = 0x00000001
GL_AFFINE_2D_NV = 0x00009092
GL_OES_texture_cube_map_array = 0x00000001
GL_GLYPH_HEIGHT_BIT_NV = 0x00000002
GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x00008a32
GL_PROGRAM_BINARY_ANGLE = 0x000093a6
GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES = 0x00008de1
GL_SHADER_PIXEL_LOCAL_STORAGE_EXT = 0x00008f64
GL_OES_sample_shading = 0x00000001
GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = 0x00008c4e
GL_BUFFER_OBJECT_EXT = 0x00009151
GL_TEXTURE_BUFFER_BINDING_EXT = 0x00008c2a
GL_MAP_WRITE_BIT_EXT = 0x00000002
GL_DST_ATOP_NV = 0x0000928f
GL_PATH_DASH_OFFSET_RESET_NV = 0x000090b4
GL_COLOR_BUFFER_BIT6_QCOM = 0x00000040
GL_STENCIL_BUFFER_BIT7_QCOM = 0x00800000
GL_WRITE_ONLY_OES = 0x000088b9
GL_APPLE_sync = 0x00000001
GL_RELATIVE_ROUNDED_RECT4_NV = 0x000000ed
GL_PRIMITIVES_GENERATED_OES = 0x00008c87
GL_TRANSLATE_X_NV = 0x0000908e
GL_ARM_rgba8 = 0x00000001
GL_COMPRESSED_RGBA_ASTC_6x5x5_OES = 0x000093c7
GL_MULTISAMPLE_BUFFER_BIT4_QCOM = 0x10000000
GL_HARDMIX_NV = 0x000092a9
GL_FRAGMENT_COVERAGE_COLOR_NV = 0x000092de
GL_ALL_COMPLETED_NV = 0x000084f2
GL_TEXTURE_BINDING_3D_OES = 0x0000806a
GL_COLOR_BUFFER_BIT2_QCOM = 0x00000004
GL_MAP_UNSYNCHRONIZED_BIT_EXT = 0x00000020
GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE = 0x000083f2
GL_TEXTURE_BINDING_BUFFER_EXT = 0x00008c2c
GL_BGRA8_EXT = 0x000093a1
GL_EXT_texture_sRGB_R8 = 0x00000001
GL_RELATIVE_RECT_NV = 0x000000f7
GL_SRC_ATOP_NV = 0x0000928e
GL_RGB_RAW_422_APPLE = 0x00008a51
GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG = 0x000093f1
GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT = 0x00004000
GL_READ_FRAMEBUFFER_ANGLE = 0x00008ca8
GL_PERFQUERY_DONOT_FLUSH_INTEL = 0x000083f9
GL_NV_instanced_arrays = 0x00000001
GL_TEXTURE_CUBE_MAP_ARRAY_EXT = 0x00009009
GL_CLIP_DISTANCE2_APPLE = 0x00003002
GL_UNPACK_SKIP_ROWS_EXT = 0x00000cf3
GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT = 0x00009312
GL_PATH_JOIN_STYLE_NV = 0x00009079
GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = 0x00008a57
GL_GLYPH_VERTICAL_BEARING_X_BIT_NV = 0x00000020
GL_MULTISAMPLE_BUFFER_BIT0_QCOM = 0x01000000
GL_LOCATION_INDEX_EXT = 0x0000930f
GL_FETCH_PER_SAMPLE_ARM = 0x00008f65
GL_COVERAGE_ALL_FRAGMENTS_NV = 0x00008ed5
GL_TEXTURE_EXTERNAL_OES = 0x00008d65
GL_COMPRESSED_SRGB_S3TC_DXT1_NV = 0x00008c4c
GL_TRANSPOSE_AFFINE_3D_NV = 0x00009098
GL_READ_BUFFER_EXT = 0x00000c02
GL_ACCUM_ADJACENT_PAIRS_NV = 0x000090ad
GL_OVERLAY_NV = 0x00009296
GL_QCOM_perfmon_global_mode = 0x00000001
GL_GEOMETRY_LINKED_VERTICES_OUT_EXT = 0x00008916
GL_SRC_ALPHA_SATURATE_EXT = 0x00000308
GL_ALPHA_TEST_REF_QCOM = 0x00000bc2
GL_KHR_blend_equation_advanced_coherent = 0x00000001
GL_DARKEN_KHR = 0x00009297
GL_EXT_instanced_arrays = 0x00000001
GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = 0x000094f3
GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = 0x00009349
GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV = 0x00000040
GL_SRGB_ALPHA_EXT = 0x00008c42
GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = 0x00000008
GL_OES_texture_compression_astc = 0x00000001
GL_TEXTURE_HEIGHT_QCOM = 0x00008bd3
GL_OES_texture_half_float = 0x00000001
GL_FLOAT_MAT4x2_NV = 0x00008b69
GL_OES_rgb8_rgba8 = 0x00000001
GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = 0x00009348
GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT = 0x000088fc
GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES = 0x00008c29
GL_PLUS_CLAMPED_ALPHA_NV = 0x000092b2
GL_UTF16_NV = 0x0000909b
GL_MAP_READ_BIT = 0x00000001
GL_ANGLE_translated_shader_source = 0x00000001
GL_DRAW_BUFFER10_NV = 0x0000882f
GL_NV_fill_rectangle = 0x00000001
GL_DRAW_BUFFER9_EXT = 0x0000882e
GL_EXT_texture_format_BGRA8888 = 0x00000001
GL_PALETTE4_RGBA8_OES = 0x00008b91
GL_BGRA_IMG = 0x000080e1
GL_PATH_FILL_MODE_NV = 0x00009080
GL_DEPTH_COMPONENT24_OES = 0x000081a6
GL_RASTER_SAMPLES_EXT = 0x00009328
GL_DEBUG_TYPE_PERFORMANCE_KHR = 0x00008250
GL_RGBA32F_EXT = 0x00008814
GL_AMD_program_binary_Z400 = 0x00000001
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x000093d2
GL_TEXTURE_BUFFER_OFFSET_OES = 0x0000919d
GL_DRAW_BUFFER7_NV = 0x0000882c
GL_CURRENT_QUERY_EXT = 0x00008865
GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = 0x00009500
GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = 0x00009138
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x000093db
GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES = 0x00008e89
GL_IMG_read_format = 0x00000001
GL_DRAW_FRAMEBUFFER_BINDING_APPLE = 0x00008ca6
GL_TEXTURE_VIEW_NUM_LEVELS_EXT = 0x000082dc
GL_DRAW_BUFFER5_NV = 0x0000882a
GL_OES_compressed_ETC1_RGB8_sub_texture = 0x00000001
GL_COLOR_ATTACHMENT5_EXT = 0x00008ce5
GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES = 0x000092d3
GL_NV_coverage_sample = 0x00000001
GL_EXT_gpu_shader5 = 0x00000001
GL_OES_shader_io_blocks = 0x00000001
GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = 0x00008c4f
GL_UNDEFINED_VERTEX_OES = 0x00008260
GL_EXT_shader_texture_lod = 0x00000001
GL_UNKNOWN_CONTEXT_RESET_EXT = 0x00008255
GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x0000905f
GL_DEPTH_BUFFER_BIT7_QCOM = 0x00008000
GL_PERFQUERY_SINGLE_CONTEXT_INTEL = 0x00000000
GL_NV_read_buffer_front = 0x00000001
GL_SQUARE_NV = 0x000090a3
GL_COMPRESSED_RGBA_ASTC_5x5_KHR = 0x000093b2
GL_SYNC_FLUSH_COMMANDS_BIT_APPLE = 0x00000001
GL_COPY_WRITE_BUFFER_NV = 0x00008f37
GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV = 0x0000933d
GL_SHADER_KHR = 0x000082e1
GL_NUM_SPARSE_LEVELS_EXT = 0x000091aa
GL_MAP_COHERENT_BIT_EXT = 0x00000080
GL_PATH_STROKE_BOUNDING_BOX_NV = 0x000090a2
GL_ANDROID_extension_pack_es31a = 0x00000001
GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT = 0x00008e89
GL_COLOR_ATTACHMENT10_NV = 0x00008cea
GL_ISOLINES_OES = 0x00008e7a
GL_RGB16_SNORM_EXT = 0x00008f9a
GL_DRAW_BUFFER12_NV = 0x00008831
GL_DEPTH_BUFFER_BIT0_QCOM = 0x00000100
GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV = 0x00000004
GL_INT_IMAGE_BUFFER_OES = 0x0000905c
GL_ROUNDED_RECT8_NV = 0x000000ee
GL_DRAW_BUFFER2_NV = 0x00008827
GL_DRAW_BUFFER5_EXT = 0x0000882a
GL_SOFTLIGHT_KHR = 0x0000929c
GL_PERFQUERY_FLUSH_INTEL = 0x000083fa
GL_APPLE_clip_distance = 0x00000001
GL_MAX_SERVER_WAIT_TIMEOUT_APPLE = 0x00009111
GL_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x0000887f
GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x00008e1e
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = 0x000093e4
GL_TEXTURE_VIEW_MIN_LAYER_EXT = 0x000082dd
GL_CONSERVATIVE_RASTERIZATION_NV = 0x00009346
GL_SMAPHS_PROGRAM_BINARY_DMP = 0x00009252
GL_ALPHA32F_EXT = 0x00008816
GL_BUFFER_ACCESS_OES = 0x000088bb
GL_KHR_texture_compression_astc_ldr = 0x00000001
GL_DEBUG_LOGGED_MESSAGES_KHR = 0x00009145
GL_CONDITION_SATISFIED_APPLE = 0x0000911c
GL_OES_geometry_shader = 0x00000001
GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT = 0x0000919a
GL_EXT_pvrtc_sRGB = 0x00000001
GL_RELATIVE_LARGE_CCW_ARC_TO_NV = 0x00000017
GL_QCOM_extended_get = 0x00000001
GL_NV_blend_equation_advanced_coherent = 0x00000001
GL_TESS_GEN_POINT_MODE_EXT = 0x00008e79
GL_CLIP_DISTANCE1_APPLE = 0x00003001
GL_TESS_EVALUATION_SHADER_BIT_OES = 0x00000010
GL_READ_FRAMEBUFFER_BINDING_NV = 0x00008caa
GL_DEBUG_SOURCE_OTHER_KHR = 0x0000824b
GL_SAMPLER_CUBE_MAP_ARRAY_OES = 0x0000900c
GL_DEPTH24_STENCIL8_OES = 0x000088f0
GL_COPY_READ_BUFFER_NV = 0x00008f36
GL_DRAW_FRAMEBUFFER_BINDING_ANGLE = 0x00008ca6
GL_MAX_TESS_PATCH_COMPONENTS_OES = 0x00008e84
GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = 0x00008a54
GL_OES_texture_float = 0x00000001
GL_CONFORMANT_NV = 0x00009374
GL_DEBUG_TYPE_MARKER_KHR = 0x00008268
GL_MAX_DEBUG_LOGGED_MESSAGES_KHR = 0x00009144
GL_CLOSE_PATH_NV = 0x00000000
GL_PALETTE4_RGB5_A1_OES = 0x00008b94
GL_TRIANGLE_STRIP_ADJACENCY_OES = 0x0000000d
GL_NV_shadow_samplers_cube = 0x00000001
GL_HSL_COLOR_NV = 0x000092af
GL_EXT_debug_marker = 0x00000001
GL_LUMINANCE8_ALPHA8_EXT = 0x00008045
GL_UNSIGNED_INT64_AMD = 0x00008bc2
GL_ALPHA_TEST_FUNC_QCOM = 0x00000bc1
GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = 0x00008f67
GL_NV_shader_noperspective_interpolation = 0x00000001
GL_MULTIVIEW_EXT = 0x000090f1
GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = 0x000094fc
GL_TEXTURE_BUFFER_SIZE_OES = 0x0000919e
GL_MALI_PROGRAM_BINARY_ARM = 0x00008f61
GL_PERFMON_RESULT_AMD = 0x00008bc6
GL_DEBUG_SEVERITY_HIGH_KHR = 0x00009146
GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES = 0x00009123
GL_OES_tessellation_point_size = 0x00000001
GL_PATH_STENCIL_REF_NV = 0x000090b8
GL_OES_depth_texture = 0x00000001
GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = 0x00008221
GL_SRC_OVER_NV = 0x00009288
GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = 0x00008e5d
GL_PACK_REVERSE_ROW_ORDER_ANGLE = 0x000093a4
GL_SAMPLER_BUFFER_OES = 0x00008dc2
GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x00008e80
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = 0x000093e7
GL_OES_surfaceless_context = 0x00000001
GL_READ_BUFFER_NV = 0x00000c02
GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x00008211
GL_COLOR_ATTACHMENT4_NV = 0x00008ce4
GL_MINUS_CLAMPED_NV = 0x000092b3
GL_EXT_shader_framebuffer_fetch = 0x00000001
GL_FONT_UNDERLINE_POSITION_BIT_NV = 0x04000000
GL_DMP_shader_binary = 0x00000001
GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x00008a32
GL_NV_texture_compression_s3tc_update = 0x00000001
GL_MULTIPLY_NV = 0x00009294
GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT = 0x0000886d
GL_ANGLE_program_binary = 0x00000001
GL_TEXTURE_3D = 0x0000806f
GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = 0x0000932b
GL_MAP_READ_BIT_EXT = 0x00000001
GL_ANGLE_texture_compression_dxt3 = 0x00000001
GL_DEBUG_SOURCE_API_KHR = 0x00008246
GL_CLAMP_TO_BORDER_EXT = 0x0000812d
GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = 0x00008248
GL_TEXTURE_COMPARE_FUNC_EXT = 0x0000884d
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x000093d5
GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES = 0x000090cd
GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES = 0x000092ce
GL_PINLIGHT_NV = 0x000092a8
GL_LOSE_CONTEXT_ON_RESET_EXT = 0x00008252
GL_QUERY_WAIT_NV = 0x00008e13
GL_COLOR_ATTACHMENT3_EXT = 0x00008ce3
GL_LUMINANCE8_OES = 0x00008040
GL_APPLE_texture_max_level = 0x00000001
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = 0x000093e9
GL_PATH_COVER_DEPTH_FUNC_NV = 0x000090bf
GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT = 0x000092cd
GL_SCREEN_KHR = 0x00009295
GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV = 0x000088fe
GL_EXT_texture_compression_dxt1 = 0x00000001
GL_MIN_EXT = 0x00008007
GL_TEXTURE_INTERNAL_FORMAT_QCOM = 0x00008bd5
GL_LAST_VERTEX_CONVENTION_OES = 0x00008e4e
GL_RENDERBUFFER_SAMPLES_ANGLE = 0x00008cab
GL_NV_framebuffer_multisample = 0x00000001
GL_CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002
GL_COLOR_ATTACHMENT14_EXT = 0x00008cee
GL_COMPRESSED_RGBA_ASTC_5x5x4_OES = 0x000093c5
GL_MAX_RASTER_SAMPLES_EXT = 0x00009329
GL_OES_EGL_image = 0x00000001
GL_MULTISAMPLES_NV = 0x00009371
GL_LINE_STRIP_ADJACENCY_OES = 0x0000000b
GL_UNSIGNED_SHORT_8_8_APPLE = 0x000085ba
GL_MITER_TRUNCATE_NV = 0x000090a8
GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = 0x00008de0
GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT = 0x000091a9
GL_COLOR_ATTACHMENT8_NV = 0x00008ce8
GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES = 0x000090d7
GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = 0x0000824d
GL_TIMEOUT_IGNORED_APPLE = 0xffffffffffffffff
GL_FRAMEBUFFER_ATTACHMENT_ANGLE = 0x000093a3
GL_APPLE_rgb_422 = 0x00000001
GL_TESS_GEN_POINT_MODE_OES = 0x00008e79
GL_MAX_SPARSE_TEXTURE_SIZE_EXT = 0x00009198
GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT = 0x00008e83
GL_HSL_SATURATION_NV = 0x000092ae
GL_NV_blend_equation_advanced = 0x00000001
GL_PLUS_NV = 0x00009291
GL_IS_PER_PATCH_OES = 0x000092e7
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = 0x00009630
GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = 0x0000933f
GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x00008c00
GL_TESS_GEN_MODE_OES = 0x00008e76
__gl2ext_h_ = 0x00000001
GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT = 0x0000932a
GL_FONT_GLYPHS_AVAILABLE_NV = 0x00009368
GL_ETC1_RGB8_OES = 0x00008d64
GL_WAIT_FAILED_APPLE = 0x0000911d
GL_EXT_texture_filter_anisotropic = 0x00000001
GL_PERFMON_RESULT_AVAILABLE_AMD = 0x00008bc4
GL_PROGRAM_BINARY_LENGTH_OES = 0x00008741
GL_NO_RESET_NOTIFICATION_EXT = 0x00008261
GL_OES_depth24 = 0x00000001
GL_INT_SAMPLER_BUFFER_EXT = 0x00008dd0
GL_MITER_REVERT_NV = 0x000090a7
GL_COVERAGE_ATTACHMENT_NV = 0x00008ed2
GL_DEBUG_SEVERITY_MEDIUM_KHR = 0x00009147
GL_TEXTURE_2D_ARRAY = 0x00008c1a
GL_MAX_VIEWS_OVR = 0x00009631
GL_STENCIL_SAMPLES_NV = 0x0000932e
GL_DRAW_BUFFER1_EXT = 0x00008826
GL_MULTISAMPLE_BUFFER_BIT3_QCOM = 0x08000000
GL_COLOR_BUFFER_BIT1_QCOM = 0x00000002
GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = 0x000084e3
GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x00008e5a
GL_SAMPLER_CUBE_SHADOW_NV = 0x00008dc5
GL_RGB16_EXT = 0x00008054
GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG = 0x00008365
GL_EXT_render_snorm = 0x00000001
GL_DRAW_BUFFER0_NV = 0x00008825
GL_DEBUG_TYPE_POP_GROUP_KHR = 0x0000826a
GL_EXT_map_buffer_range = 0x00000001
GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT = 0x000092d3
GL_SOFTLIGHT_NV = 0x0000929c
GL_GPU_DISJOINT_EXT = 0x00008fbb
GL_TEXTURE_USAGE_ANGLE = 0x000093a2
GL_EXT_float_blend = 0x00000001
GL_DRAW_BUFFER3_EXT = 0x00008828
GL_VIEWPORT_BOUNDS_RANGE_NV = 0x0000825d
GL_ARM_shader_framebuffer_fetch_depth_stencil = 0x00000001
GL_FONT_UNDERLINE_THICKNESS_BIT_NV = 0x08000000
GL_TEXTURE_BUFFER_BINDING_OES = 0x00008c2a
GL_TIMESTAMP_EXT = 0x00008e28
GL_MALI_SHADER_BINARY_ARM = 0x00008f60
GL_OES_EGL_image_external = 0x00000001
GL_ALREADY_SIGNALED_APPLE = 0x0000911a
GL_COLOR_ATTACHMENT2_NV = 0x00008ce2
GL_APPLE_texture_format_BGRA8888 = 0x00000001
GL_MAX = 0x00008008
GL_TEXTURE_SPARSE_EXT = 0x000091a6
GL_CLIENT_STORAGE_BIT_EXT = 0x00000200
GL_TEXTURE_BINDING_BUFFER_OES = 0x00008c2c
GL_NV_shadow_samplers_array = 0x00000001
GL_INVERT_RGB_NV = 0x000092a3
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x000093da
GL_LIGHTEN_KHR = 0x00009298
GL_NV_bindless_texture = 0x00000001
GL_DRAW_FRAMEBUFFER_APPLE = 0x00008ca9
GL_ARM_mali_shader_binary = 0x00000001
GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x00008e5b
GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = 0x000094f9
GL_COMPRESSED_RGBA_ASTC_4x3x3_OES = 0x000093c1
GL_MAP_INVALIDATE_RANGE_BIT_EXT = 0x00000004
GL_PATH_MITER_LIMIT_NV = 0x0000907a
GL_LINE_NV = 0x00001b01
GL_QUERY_BY_REGION_WAIT_NV = 0x00008e15
GL_TESS_CONTROL_SHADER_OES = 0x00008e88
GL_EXT_texture_rg = 0x00000001
GL_HSL_SATURATION_KHR = 0x000092ae
GL_GCCSO_SHADER_BINARY_FJ = 0x00009260
GL_STENCIL_BUFFER_BIT4_QCOM = 0x00100000
GL_DEBUG_TYPE_PORTABILITY_KHR = 0x0000824f
GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x000084fe
GL_EFFECTIVE_RASTER_SAMPLES_EXT = 0x0000932c
GL_COLOR_ATTACHMENT0_NV = 0x00008ce0
GL_ONE_MINUS_SRC1_ALPHA_EXT = 0x000088fb
GL_DEBUG_SEVERITY_LOW_KHR = 0x00009148
GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x00008e7f
GL_OES_primitive_bounding_box = 0x00000001
GL_LUMINANCE16F_EXT = 0x0000881e
GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES = 0x00009102
GL_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x0000905f
GL_EXCLUSION_NV = 0x000092a0
GL_INNOCENT_CONTEXT_RESET_EXT = 0x00008254
GL_CONTEXT_ROBUST_ACCESS_KHR = 0x000090f3
GL_PATH_STROKE_MASK_NV = 0x00009084
GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES = 0x00008e5a
GL_TEXTURE_MAX_LEVEL_APPLE = 0x0000813d
GL_DRAW_BUFFER2_EXT = 0x00008827
GL_AMD_compressed_ATC_texture = 0x00000001
GL_PATH_GEN_COEFF_NV = 0x000090b1
GL_ROUNDED_RECT4_NV = 0x000000ec
GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT = 0x00008e8a
GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES = 0x000092cf
GL_INT_IMAGE_BUFFER_EXT = 0x0000905c
GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x00008e1f
GL_ALPHA16F_EXT = 0x0000881c
GL_COMPRESSED_RGBA_ASTC_5x4_KHR = 0x000093b1
GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = 0x000093e8
GL_HARDLIGHT_NV = 0x0000929b
GL_RG16F_EXT = 0x0000822f
GL_DRAW_BUFFER11_EXT = 0x00008830
GL_TRANSLATE_2D_NV = 0x00009090
GL_BLEND_ADVANCED_COHERENT_NV = 0x00009285
GL_KHR_context_flush_control = 0x00000001
GL_SAMPLER = 0x000082e6
GL_LINEARBURN_NV = 0x000092a5

# GL Functions
try:
    def glBlendBarrierKHR(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glBlendBarrierKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glBlendBarrierKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDebugMessageControlKHR(source, type, severity, count, param0, enabled, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLenum, GLsizei, GLuint, GLboolean]
        cfunc = c.glDebugMessageControlKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(source, type, severity, count, param0, enabled)
    # Check if the function actually exists
    f = c.glDebugMessageControlKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDebugMessageInsertKHR(source, type, id, severity, length, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint, GLenum, GLsizei, GLchar]
        cfunc = c.glDebugMessageInsertKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(source, type, id, severity, length, param0)
    # Check if the function actually exists
    f = c.glDebugMessageInsertKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDebugMessageCallbackKHR(callback, voiduserParam, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLDEBUGPROCKHR, ctypes.c_void_p]
        cfunc = c.glDebugMessageCallbackKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(callback, voiduserParam)
    # Check if the function actually exists
    f = c.glDebugMessageCallbackKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetDebugMessageLogKHR(count, bufSize, param0, param1, param2, param3, param4, param5, argtypes_p=None):
        restype = GLuint
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLenum, GLenum, GLuint, GLenum, GLsizei, GLchar]
        cfunc = c.glGetDebugMessageLogKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(count, bufSize, param0, param1, param2, param3, param4, param5)
    # Check if the function actually exists
    f = c.glGetDebugMessageLogKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPushDebugGroupKHR(source, id, length, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLsizei, GLchar]
        cfunc = c.glPushDebugGroupKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(source, id, length, param0)
    # Check if the function actually exists
    f = c.glPushDebugGroupKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPopDebugGroupKHR(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glPopDebugGroupKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glPopDebugGroupKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glObjectLabelKHR(identifier, name, length, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLsizei, GLchar]
        cfunc = c.glObjectLabelKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(identifier, name, length, param0)
    # Check if the function actually exists
    f = c.glObjectLabelKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetObjectLabelKHR(identifier, name, bufSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetObjectLabelKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(identifier, name, bufSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetObjectLabelKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glObjectPtrLabelKHR(voidptr, length, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p, GLsizei, GLchar]
        cfunc = c.glObjectPtrLabelKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(voidptr, length, param0)
    # Check if the function actually exists
    f = c.glObjectPtrLabelKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetObjectPtrLabelKHR(voidptr, bufSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetObjectPtrLabelKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(voidptr, bufSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetObjectPtrLabelKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPointervKHR(pname, voidparams, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, ctypes.c_void_p]
        cfunc = c.glGetPointervKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pname, voidparams)
    # Check if the function actually exists
    f = c.glGetPointervKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetGraphicsResetStatusKHR(void, argtypes_p=None):
        restype = GLenum
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glGetGraphicsResetStatusKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glGetGraphicsResetStatusKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glReadnPixelsKHR(x, y, width, height, format, type, bufSize, voiddata, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, ctypes.c_void_p]
        cfunc = c.glReadnPixelsKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(x, y, width, height, format, type, bufSize, voiddata)
    # Check if the function actually exists
    f = c.glReadnPixelsKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetnUniformfvKHR(program, location, bufSize, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLfloat]
        cfunc = c.glGetnUniformfvKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, bufSize, param0)
    # Check if the function actually exists
    f = c.glGetnUniformfvKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetnUniformivKHR(program, location, bufSize, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLint]
        cfunc = c.glGetnUniformivKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, bufSize, param0)
    # Check if the function actually exists
    f = c.glGetnUniformivKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetnUniformuivKHR(program, location, bufSize, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLuint]
        cfunc = c.glGetnUniformuivKHR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, bufSize, param0)
    # Check if the function actually exists
    f = c.glGetnUniformuivKHR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEGLImageTargetTexture2DOES(target, image, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLeglImageOES]
        cfunc = c.glEGLImageTargetTexture2DOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, image)
    # Check if the function actually exists
    f = c.glEGLImageTargetTexture2DOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEGLImageTargetRenderbufferStorageOES(target, image, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLeglImageOES]
        cfunc = c.glEGLImageTargetRenderbufferStorageOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, image)
    # Check if the function actually exists
    f = c.glEGLImageTargetRenderbufferStorageOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCopyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint, GLint, GLint, GLint, GLuint, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei]
        cfunc = c.glCopyImageSubDataOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
    # Check if the function actually exists
    f = c.glCopyImageSubDataOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEnableiOES(target, index, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glEnableiOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glEnableiOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDisableiOES(target, index, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glDisableiOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glDisableiOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendEquationiOES(buf, mode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum]
        cfunc = c.glBlendEquationiOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, mode)
    # Check if the function actually exists
    f = c.glBlendEquationiOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendEquationSeparateiOES(buf, modeRGB, modeAlpha, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLenum]
        cfunc = c.glBlendEquationSeparateiOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, modeRGB, modeAlpha)
    # Check if the function actually exists
    f = c.glBlendEquationSeparateiOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendFunciOES(buf, src, dst, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLenum]
        cfunc = c.glBlendFunciOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, src, dst)
    # Check if the function actually exists
    f = c.glBlendFunciOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLenum, GLenum, GLenum]
        cfunc = c.glBlendFuncSeparateiOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
    # Check if the function actually exists
    f = c.glBlendFuncSeparateiOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glColorMaskiOES(index, r, g, b, a, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLboolean, GLboolean, GLboolean, GLboolean]
        cfunc = c.glColorMaskiOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, r, g, b, a)
    # Check if the function actually exists
    f = c.glColorMaskiOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsEnablediOES(target, index, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glIsEnablediOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glIsEnablediOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsBaseVertexOES(mode, count, type, voidindices, basevertex, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLint]
        cfunc = c.glDrawElementsBaseVertexOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, basevertex)
    # Check if the function actually exists
    f = c.glDrawElementsBaseVertexOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawRangeElementsBaseVertexOES(mode, start, end, count, type, voidindices, basevertex, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLuint, GLsizei, GLenum, ctypes.c_void_p, GLint]
        cfunc = c.glDrawRangeElementsBaseVertexOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, start, end, count, type, voidindices, basevertex)
    # Check if the function actually exists
    f = c.glDrawRangeElementsBaseVertexOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsInstancedBaseVertexOES(mode, count, type, voidindices, instancecount, basevertex, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei, GLint]
        cfunc = c.glDrawElementsInstancedBaseVertexOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, instancecount, basevertex)
    # Check if the function actually exists
    f = c.glDrawElementsInstancedBaseVertexOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMultiDrawElementsBaseVertexOES(mode, param0, type, voidconstindices, primcount, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei, GLint]
        cfunc = c.glMultiDrawElementsBaseVertexOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, param0, type, voidconstindices, primcount, param1)
    # Check if the function actually exists
    f = c.glMultiDrawElementsBaseVertexOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFramebufferTextureOES(target, attachment, texture, level, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint, GLint]
        cfunc = c.glFramebufferTextureOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, attachment, texture, level)
    # Check if the function actually exists
    f = c.glFramebufferTextureOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetProgramBinaryOES(program, bufSize, param0, param1, voidbinary, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLenum, ctypes.c_void_p]
        cfunc = c.glGetProgramBinaryOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, bufSize, param0, param1, voidbinary)
    # Check if the function actually exists
    f = c.glGetProgramBinaryOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramBinaryOES(program, binaryFormat, voidbinary, length, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, ctypes.c_void_p, GLint]
        cfunc = c.glProgramBinaryOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, binaryFormat, voidbinary, length)
    # Check if the function actually exists
    f = c.glProgramBinaryOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUnmapBufferOES(target, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum]
        cfunc = c.glUnmapBufferOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target)
    # Check if the function actually exists
    f = c.glUnmapBufferOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetBufferPointervOES(target, pname, voidparams, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, ctypes.c_void_p]
        cfunc = c.glGetBufferPointervOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, voidparams)
    # Check if the function actually exists
    f = c.glGetBufferPointervOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat]
        cfunc = c.glPrimitiveBoundingBoxOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW)
    # Check if the function actually exists
    f = c.glPrimitiveBoundingBoxOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMinSampleShadingOES(value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLfloat]
        cfunc = c.glMinSampleShadingOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(value)
    # Check if the function actually exists
    f = c.glMinSampleShadingOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPatchParameteriOES(pname, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint]
        cfunc = c.glPatchParameteriOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pname, value)
    # Check if the function actually exists
    f = c.glPatchParameteriOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexImage3DOES(target, level, internalformat, width, height, depth, border, format, type, voidpixels, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, ctypes.c_void_p]
        cfunc = c.glTexImage3DOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, level, internalformat, width, height, depth, border, format, type, voidpixels)
    # Check if the function actually exists
    f = c.glTexImage3DOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, voidpixels, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, ctypes.c_void_p]
        cfunc = c.glTexSubImage3DOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, voidpixels)
    # Check if the function actually exists
    f = c.glTexSubImage3DOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei]
        cfunc = c.glCopyTexSubImage3DOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, level, xoffset, yoffset, zoffset, x, y, width, height)
    # Check if the function actually exists
    f = c.glCopyTexSubImage3DOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, voiddata, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, ctypes.c_void_p]
        cfunc = c.glCompressedTexImage3DOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, level, internalformat, width, height, depth, border, imageSize, voiddata)
    # Check if the function actually exists
    f = c.glCompressedTexImage3DOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, voiddata, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, ctypes.c_void_p]
        cfunc = c.glCompressedTexSubImage3DOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, voiddata)
    # Check if the function actually exists
    f = c.glCompressedTexSubImage3DOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLenum, GLuint, GLint, GLint]
        cfunc = c.glFramebufferTexture3DOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, attachment, textarget, texture, level, zoffset)
    # Check if the function actually exists
    f = c.glFramebufferTexture3DOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexParameterIivOES(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLint]
        cfunc = c.glTexParameterIivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glTexParameterIivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexParameterIuivOES(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint]
        cfunc = c.glTexParameterIuivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glTexParameterIuivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetTexParameterIivOES(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLint]
        cfunc = c.glGetTexParameterIivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glGetTexParameterIivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetTexParameterIuivOES(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint]
        cfunc = c.glGetTexParameterIuivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glGetTexParameterIuivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glSamplerParameterIivOES(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glSamplerParameterIivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glSamplerParameterIivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glSamplerParameterIuivOES(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint]
        cfunc = c.glSamplerParameterIuivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glSamplerParameterIuivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetSamplerParameterIivOES(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glGetSamplerParameterIivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glGetSamplerParameterIivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetSamplerParameterIuivOES(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint]
        cfunc = c.glGetSamplerParameterIuivOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glGetSamplerParameterIuivOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexBufferOES(target, internalformat, buffer, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint]
        cfunc = c.glTexBufferOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, internalformat, buffer)
    # Check if the function actually exists
    f = c.glTexBufferOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexBufferRangeOES(target, internalformat, buffer, offset, size, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint, GLintptr, GLsizeiptr]
        cfunc = c.glTexBufferRangeOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, internalformat, buffer, offset, size)
    # Check if the function actually exists
    f = c.glTexBufferRangeOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexStorage3DMultisampleOES(target, samples, internalformat, width, height, depth, fixedsamplelocations, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean]
        cfunc = c.glTexStorage3DMultisampleOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, samples, internalformat, width, height, depth, fixedsamplelocations)
    # Check if the function actually exists
    f = c.glTexStorage3DMultisampleOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTextureViewOES(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint, GLenum, GLuint, GLuint, GLuint, GLuint]
        cfunc = c.glTextureViewOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)
    # Check if the function actually exists
    f = c.glTextureViewOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBindVertexArrayOES(array, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glBindVertexArrayOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(array)
    # Check if the function actually exists
    f = c.glBindVertexArrayOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDeleteVertexArraysOES(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glDeleteVertexArraysOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glDeleteVertexArraysOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGenVertexArraysOES(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glGenVertexArraysOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glGenVertexArraysOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsVertexArrayOES(array, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glIsVertexArrayOES
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(array)
    # Check if the function actually exists
    f = c.glIsVertexArrayOES
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfMonitorGroupsAMD(param0, groupsSize, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLuint]
        cfunc = c.glGetPerfMonitorGroupsAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, groupsSize, param1)
    # Check if the function actually exists
    f = c.glGetPerfMonitorGroupsAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfMonitorCountersAMD(group, param0, param1, counterSize, param2, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint, GLsizei, GLuint]
        cfunc = c.glGetPerfMonitorCountersAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(group, param0, param1, counterSize, param2)
    # Check if the function actually exists
    f = c.glGetPerfMonitorCountersAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfMonitorGroupStringAMD(group, bufSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetPerfMonitorGroupStringAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(group, bufSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetPerfMonitorGroupStringAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfMonitorCounterStringAMD(group, counter, bufSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetPerfMonitorCounterStringAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(group, counter, bufSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetPerfMonitorCounterStringAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfMonitorCounterInfoAMD(group, counter, pname, voiddata, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLenum, ctypes.c_void_p]
        cfunc = c.glGetPerfMonitorCounterInfoAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(group, counter, pname, voiddata)
    # Check if the function actually exists
    f = c.glGetPerfMonitorCounterInfoAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGenPerfMonitorsAMD(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glGenPerfMonitorsAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glGenPerfMonitorsAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDeletePerfMonitorsAMD(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glDeletePerfMonitorsAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glDeletePerfMonitorsAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLboolean, GLuint, GLint, GLuint]
        cfunc = c.glSelectPerfMonitorCountersAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(monitor, enable, group, numCounters, param0)
    # Check if the function actually exists
    f = c.glSelectPerfMonitorCountersAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBeginPerfMonitorAMD(monitor, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glBeginPerfMonitorAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(monitor)
    # Check if the function actually exists
    f = c.glBeginPerfMonitorAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEndPerfMonitorAMD(monitor, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glEndPerfMonitorAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(monitor)
    # Check if the function actually exists
    f = c.glEndPerfMonitorAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLsizei, GLuint, GLint]
        cfunc = c.glGetPerfMonitorCounterDataAMD
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(monitor, pname, dataSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetPerfMonitorCounterDataAMD
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum]
        cfunc = c.glBlitFramebufferANGLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    # Check if the function actually exists
    f = c.glBlitFramebufferANGLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glRenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei]
        cfunc = c.glRenderbufferStorageMultisampleANGLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, samples, internalformat, width, height)
    # Check if the function actually exists
    f = c.glRenderbufferStorageMultisampleANGLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawArraysInstancedANGLE(mode, first, count, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLsizei, GLsizei]
        cfunc = c.glDrawArraysInstancedANGLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, first, count, primcount)
    # Check if the function actually exists
    f = c.glDrawArraysInstancedANGLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsInstancedANGLE(mode, count, type, voidindices, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei]
        cfunc = c.glDrawElementsInstancedANGLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, primcount)
    # Check if the function actually exists
    f = c.glDrawElementsInstancedANGLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glVertexAttribDivisorANGLE(index, divisor, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glVertexAttribDivisorANGLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, divisor)
    # Check if the function actually exists
    f = c.glVertexAttribDivisorANGLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetTranslatedShaderSourceANGLE(shader, bufsize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetTranslatedShaderSourceANGLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(shader, bufsize, param0, param1)
    # Check if the function actually exists
    f = c.glGetTranslatedShaderSourceANGLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLint, GLsizei]
        cfunc = c.glCopyTextureLevelsAPPLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount)
    # Check if the function actually exists
    f = c.glCopyTextureLevelsAPPLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glRenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei]
        cfunc = c.glRenderbufferStorageMultisampleAPPLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, samples, internalformat, width, height)
    # Check if the function actually exists
    f = c.glRenderbufferStorageMultisampleAPPLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glResolveMultisampleFramebufferAPPLE(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glResolveMultisampleFramebufferAPPLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glResolveMultisampleFramebufferAPPLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetInteger64vAPPLE(pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint64]
        cfunc = c.glGetInteger64vAPPLE
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pname, param0)
    # Check if the function actually exists
    f = c.glGetInteger64vAPPLE
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawArraysInstancedBaseInstanceEXT(mode, first, count, instancecount, baseinstance, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLsizei, GLsizei, GLuint]
        cfunc = c.glDrawArraysInstancedBaseInstanceEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, first, count, instancecount, baseinstance)
    # Check if the function actually exists
    f = c.glDrawArraysInstancedBaseInstanceEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsInstancedBaseInstanceEXT(mode, count, type, voidindices, instancecount, baseinstance, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei, GLuint]
        cfunc = c.glDrawElementsInstancedBaseInstanceEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, instancecount, baseinstance)
    # Check if the function actually exists
    f = c.glDrawElementsInstancedBaseInstanceEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsInstancedBaseVertexBaseInstanceEXT(mode, count, type, voidindices, instancecount, basevertex, baseinstance, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei, GLint, GLuint]
        cfunc = c.glDrawElementsInstancedBaseVertexBaseInstanceEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, instancecount, basevertex, baseinstance)
    # Check if the function actually exists
    f = c.glDrawElementsInstancedBaseVertexBaseInstanceEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBindFragDataLocationIndexedEXT(program, colorNumber, index, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLuint, GLchar]
        cfunc = c.glBindFragDataLocationIndexedEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, colorNumber, index, param0)
    # Check if the function actually exists
    f = c.glBindFragDataLocationIndexedEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBindFragDataLocationEXT(program, color, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLchar]
        cfunc = c.glBindFragDataLocationEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, color, param0)
    # Check if the function actually exists
    f = c.glBindFragDataLocationEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetProgramResourceLocationIndexEXT(program, programInterface, param0, argtypes_p=None):
        restype = GLint
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLchar]
        cfunc = c.glGetProgramResourceLocationIndexEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, programInterface, param0)
    # Check if the function actually exists
    f = c.glGetProgramResourceLocationIndexEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetFragDataIndexEXT(program, param0, argtypes_p=None):
        restype = GLint
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLchar]
        cfunc = c.glGetFragDataIndexEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, param0)
    # Check if the function actually exists
    f = c.glGetFragDataIndexEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBufferStorageEXT(target, size, voiddata, flags, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizeiptr, ctypes.c_void_p, GLbitfield]
        cfunc = c.glBufferStorageEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, size, voiddata, flags)
    # Check if the function actually exists
    f = c.glBufferStorageEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint, GLint, GLint, GLint, GLuint, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei]
        cfunc = c.glCopyImageSubDataEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
    # Check if the function actually exists
    f = c.glCopyImageSubDataEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glLabelObjectEXT(type, object, length, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLsizei, GLchar]
        cfunc = c.glLabelObjectEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(type, object, length, param0)
    # Check if the function actually exists
    f = c.glLabelObjectEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetObjectLabelEXT(type, object, bufSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetObjectLabelEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(type, object, bufSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetObjectLabelEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glInsertEventMarkerEXT(length, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLchar]
        cfunc = c.glInsertEventMarkerEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(length, param0)
    # Check if the function actually exists
    f = c.glInsertEventMarkerEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPushGroupMarkerEXT(length, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLchar]
        cfunc = c.glPushGroupMarkerEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(length, param0)
    # Check if the function actually exists
    f = c.glPushGroupMarkerEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPopGroupMarkerEXT(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glPopGroupMarkerEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glPopGroupMarkerEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDiscardFramebufferEXT(target, numAttachments, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum]
        cfunc = c.glDiscardFramebufferEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, numAttachments, param0)
    # Check if the function actually exists
    f = c.glDiscardFramebufferEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGenQueriesEXT(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glGenQueriesEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glGenQueriesEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDeleteQueriesEXT(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glDeleteQueriesEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glDeleteQueriesEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsQueryEXT(id, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glIsQueryEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(id)
    # Check if the function actually exists
    f = c.glIsQueryEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBeginQueryEXT(target, id, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glBeginQueryEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, id)
    # Check if the function actually exists
    f = c.glBeginQueryEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEndQueryEXT(target, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum]
        cfunc = c.glEndQueryEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target)
    # Check if the function actually exists
    f = c.glEndQueryEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glQueryCounterEXT(id, target, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum]
        cfunc = c.glQueryCounterEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(id, target)
    # Check if the function actually exists
    f = c.glQueryCounterEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetQueryivEXT(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLint]
        cfunc = c.glGetQueryivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glGetQueryivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetQueryObjectivEXT(id, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glGetQueryObjectivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(id, pname, param0)
    # Check if the function actually exists
    f = c.glGetQueryObjectivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetQueryObjectuivEXT(id, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint]
        cfunc = c.glGetQueryObjectuivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(id, pname, param0)
    # Check if the function actually exists
    f = c.glGetQueryObjectuivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetQueryObjecti64vEXT(id, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint64]
        cfunc = c.glGetQueryObjecti64vEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(id, pname, param0)
    # Check if the function actually exists
    f = c.glGetQueryObjecti64vEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetQueryObjectui64vEXT(id, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint64]
        cfunc = c.glGetQueryObjectui64vEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(id, pname, param0)
    # Check if the function actually exists
    f = c.glGetQueryObjectui64vEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawBuffersEXT(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum]
        cfunc = c.glDrawBuffersEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glDrawBuffersEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEnableiEXT(target, index, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glEnableiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glEnableiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDisableiEXT(target, index, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glDisableiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glDisableiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendEquationiEXT(buf, mode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum]
        cfunc = c.glBlendEquationiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, mode)
    # Check if the function actually exists
    f = c.glBlendEquationiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendEquationSeparateiEXT(buf, modeRGB, modeAlpha, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLenum]
        cfunc = c.glBlendEquationSeparateiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, modeRGB, modeAlpha)
    # Check if the function actually exists
    f = c.glBlendEquationSeparateiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendFunciEXT(buf, src, dst, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLenum]
        cfunc = c.glBlendFunciEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, src, dst)
    # Check if the function actually exists
    f = c.glBlendFunciEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLenum, GLenum, GLenum]
        cfunc = c.glBlendFuncSeparateiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
    # Check if the function actually exists
    f = c.glBlendFuncSeparateiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glColorMaskiEXT(index, r, g, b, a, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLboolean, GLboolean, GLboolean, GLboolean]
        cfunc = c.glColorMaskiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, r, g, b, a)
    # Check if the function actually exists
    f = c.glColorMaskiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsEnablediEXT(target, index, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glIsEnablediEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glIsEnablediEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsBaseVertexEXT(mode, count, type, voidindices, basevertex, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLint]
        cfunc = c.glDrawElementsBaseVertexEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, basevertex)
    # Check if the function actually exists
    f = c.glDrawElementsBaseVertexEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawRangeElementsBaseVertexEXT(mode, start, end, count, type, voidindices, basevertex, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLuint, GLsizei, GLenum, ctypes.c_void_p, GLint]
        cfunc = c.glDrawRangeElementsBaseVertexEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, start, end, count, type, voidindices, basevertex)
    # Check if the function actually exists
    f = c.glDrawRangeElementsBaseVertexEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsInstancedBaseVertexEXT(mode, count, type, voidindices, instancecount, basevertex, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei, GLint]
        cfunc = c.glDrawElementsInstancedBaseVertexEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, instancecount, basevertex)
    # Check if the function actually exists
    f = c.glDrawElementsInstancedBaseVertexEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMultiDrawElementsBaseVertexEXT(mode, param0, type, voidconstindices, primcount, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei, GLint]
        cfunc = c.glMultiDrawElementsBaseVertexEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, param0, type, voidconstindices, primcount, param1)
    # Check if the function actually exists
    f = c.glMultiDrawElementsBaseVertexEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawArraysInstancedEXT(mode, start, count, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLsizei, GLsizei]
        cfunc = c.glDrawArraysInstancedEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, start, count, primcount)
    # Check if the function actually exists
    f = c.glDrawArraysInstancedEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsInstancedEXT(mode, count, type, voidindices, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei]
        cfunc = c.glDrawElementsInstancedEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, primcount)
    # Check if the function actually exists
    f = c.glDrawElementsInstancedEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFramebufferTextureEXT(target, attachment, texture, level, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint, GLint]
        cfunc = c.glFramebufferTextureEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, attachment, texture, level)
    # Check if the function actually exists
    f = c.glFramebufferTextureEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glVertexAttribDivisorEXT(index, divisor, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glVertexAttribDivisorEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, divisor)
    # Check if the function actually exists
    f = c.glVertexAttribDivisorEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFlushMappedBufferRangeEXT(target, offset, length, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLintptr, GLsizeiptr]
        cfunc = c.glFlushMappedBufferRangeEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, offset, length)
    # Check if the function actually exists
    f = c.glFlushMappedBufferRangeEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMultiDrawArraysEXT(mode, param0, param1, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLsizei, GLsizei]
        cfunc = c.glMultiDrawArraysEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, param0, param1, primcount)
    # Check if the function actually exists
    f = c.glMultiDrawArraysEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMultiDrawElementsEXT(mode, param0, type, voidconstindices, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei]
        cfunc = c.glMultiDrawElementsEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, param0, type, voidconstindices, primcount)
    # Check if the function actually exists
    f = c.glMultiDrawElementsEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMultiDrawArraysIndirectEXT(mode, voidindirect, drawcount, stride, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, ctypes.c_void_p, GLsizei, GLsizei]
        cfunc = c.glMultiDrawArraysIndirectEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, voidindirect, drawcount, stride)
    # Check if the function actually exists
    f = c.glMultiDrawArraysIndirectEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMultiDrawElementsIndirectEXT(mode, type, voidindirect, drawcount, stride, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, ctypes.c_void_p, GLsizei, GLsizei]
        cfunc = c.glMultiDrawElementsIndirectEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, type, voidindirect, drawcount, stride)
    # Check if the function actually exists
    f = c.glMultiDrawElementsIndirectEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei]
        cfunc = c.glRenderbufferStorageMultisampleEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, samples, internalformat, width, height)
    # Check if the function actually exists
    f = c.glRenderbufferStorageMultisampleEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLenum, GLuint, GLint, GLsizei]
        cfunc = c.glFramebufferTexture2DMultisampleEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, attachment, textarget, texture, level, samples)
    # Check if the function actually exists
    f = c.glFramebufferTexture2DMultisampleEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glReadBufferIndexedEXT(src, index, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint]
        cfunc = c.glReadBufferIndexedEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(src, index)
    # Check if the function actually exists
    f = c.glReadBufferIndexedEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawBuffersIndexedEXT(n, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLenum, GLint]
        cfunc = c.glDrawBuffersIndexedEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0, param1)
    # Check if the function actually exists
    f = c.glDrawBuffersIndexedEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetIntegeri_vEXT(target, index, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLint]
        cfunc = c.glGetIntegeri_vEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index, param0)
    # Check if the function actually exists
    f = c.glGetIntegeri_vEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat]
        cfunc = c.glPrimitiveBoundingBoxEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW)
    # Check if the function actually exists
    f = c.glPrimitiveBoundingBoxEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glRasterSamplesEXT(samples, fixedsamplelocations, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLboolean]
        cfunc = c.glRasterSamplesEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(samples, fixedsamplelocations)
    # Check if the function actually exists
    f = c.glRasterSamplesEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetGraphicsResetStatusEXT(void, argtypes_p=None):
        restype = GLenum
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glGetGraphicsResetStatusEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glGetGraphicsResetStatusEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glReadnPixelsEXT(x, y, width, height, format, type, bufSize, voiddata, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, ctypes.c_void_p]
        cfunc = c.glReadnPixelsEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(x, y, width, height, format, type, bufSize, voiddata)
    # Check if the function actually exists
    f = c.glReadnPixelsEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetnUniformfvEXT(program, location, bufSize, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLfloat]
        cfunc = c.glGetnUniformfvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, bufSize, param0)
    # Check if the function actually exists
    f = c.glGetnUniformfvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetnUniformivEXT(program, location, bufSize, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLint]
        cfunc = c.glGetnUniformivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, bufSize, param0)
    # Check if the function actually exists
    f = c.glGetnUniformivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glActiveShaderProgramEXT(pipeline, program, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glActiveShaderProgramEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pipeline, program)
    # Check if the function actually exists
    f = c.glActiveShaderProgramEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBindProgramPipelineEXT(pipeline, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glBindProgramPipelineEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pipeline)
    # Check if the function actually exists
    f = c.glBindProgramPipelineEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCreateShaderProgramvEXT(type, count, param0, argtypes_p=None):
        restype = GLuint
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLchar]
        cfunc = c.glCreateShaderProgramvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(type, count, param0)
    # Check if the function actually exists
    f = c.glCreateShaderProgramvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDeleteProgramPipelinesEXT(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glDeleteProgramPipelinesEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glDeleteProgramPipelinesEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGenProgramPipelinesEXT(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glGenProgramPipelinesEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glGenProgramPipelinesEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetProgramPipelineInfoLogEXT(pipeline, bufSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetProgramPipelineInfoLogEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pipeline, bufSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetProgramPipelineInfoLogEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetProgramPipelineivEXT(pipeline, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glGetProgramPipelineivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pipeline, pname, param0)
    # Check if the function actually exists
    f = c.glGetProgramPipelineivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsProgramPipelineEXT(pipeline, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glIsProgramPipelineEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pipeline)
    # Check if the function actually exists
    f = c.glIsProgramPipelineEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramParameteriEXT(program, pname, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glProgramParameteriEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, pname, value)
    # Check if the function actually exists
    f = c.glProgramParameteriEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform1fEXT(program, location, v0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLfloat]
        cfunc = c.glProgramUniform1fEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0)
    # Check if the function actually exists
    f = c.glProgramUniform1fEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform1fvEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLfloat]
        cfunc = c.glProgramUniform1fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform1fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform1iEXT(program, location, v0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint]
        cfunc = c.glProgramUniform1iEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0)
    # Check if the function actually exists
    f = c.glProgramUniform1iEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform1ivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLint]
        cfunc = c.glProgramUniform1ivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform1ivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform2fEXT(program, location, v0, v1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLfloat, GLfloat]
        cfunc = c.glProgramUniform2fEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1)
    # Check if the function actually exists
    f = c.glProgramUniform2fEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform2fvEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLfloat]
        cfunc = c.glProgramUniform2fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform2fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform2iEXT(program, location, v0, v1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint, GLint]
        cfunc = c.glProgramUniform2iEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1)
    # Check if the function actually exists
    f = c.glProgramUniform2iEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform2ivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLint]
        cfunc = c.glProgramUniform2ivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform2ivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform3fEXT(program, location, v0, v1, v2, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLfloat, GLfloat, GLfloat]
        cfunc = c.glProgramUniform3fEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1, v2)
    # Check if the function actually exists
    f = c.glProgramUniform3fEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform3fvEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLfloat]
        cfunc = c.glProgramUniform3fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform3fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform3iEXT(program, location, v0, v1, v2, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint, GLint, GLint]
        cfunc = c.glProgramUniform3iEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1, v2)
    # Check if the function actually exists
    f = c.glProgramUniform3iEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform3ivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLint]
        cfunc = c.glProgramUniform3ivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform3ivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform4fEXT(program, location, v0, v1, v2, v3, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat]
        cfunc = c.glProgramUniform4fEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1, v2, v3)
    # Check if the function actually exists
    f = c.glProgramUniform4fEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform4fvEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLfloat]
        cfunc = c.glProgramUniform4fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform4fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform4iEXT(program, location, v0, v1, v2, v3, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint, GLint, GLint, GLint]
        cfunc = c.glProgramUniform4iEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1, v2, v3)
    # Check if the function actually exists
    f = c.glProgramUniform4iEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform4ivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLint]
        cfunc = c.glProgramUniform4ivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform4ivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix2fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix2fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix2fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix3fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix3fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix3fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix4fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix4fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix4fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUseProgramStagesEXT(pipeline, stages, program, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLbitfield, GLuint]
        cfunc = c.glUseProgramStagesEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pipeline, stages, program)
    # Check if the function actually exists
    f = c.glUseProgramStagesEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glValidateProgramPipelineEXT(pipeline, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glValidateProgramPipelineEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pipeline)
    # Check if the function actually exists
    f = c.glValidateProgramPipelineEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform1uiEXT(program, location, v0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLuint]
        cfunc = c.glProgramUniform1uiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0)
    # Check if the function actually exists
    f = c.glProgramUniform1uiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform2uiEXT(program, location, v0, v1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLuint, GLuint]
        cfunc = c.glProgramUniform2uiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1)
    # Check if the function actually exists
    f = c.glProgramUniform2uiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform3uiEXT(program, location, v0, v1, v2, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLuint, GLuint, GLuint]
        cfunc = c.glProgramUniform3uiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1, v2)
    # Check if the function actually exists
    f = c.glProgramUniform3uiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform4uiEXT(program, location, v0, v1, v2, v3, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLuint, GLuint, GLuint, GLuint]
        cfunc = c.glProgramUniform4uiEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, v0, v1, v2, v3)
    # Check if the function actually exists
    f = c.glProgramUniform4uiEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform1uivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLuint]
        cfunc = c.glProgramUniform1uivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform1uivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform2uivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLuint]
        cfunc = c.glProgramUniform2uivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform2uivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform3uivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLuint]
        cfunc = c.glProgramUniform3uivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform3uivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniform4uivEXT(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLuint]
        cfunc = c.glProgramUniform4uivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniform4uivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix2x3fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix2x3fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix3x2fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix3x2fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix2x4fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix2x4fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix4x2fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix4x2fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix3x4fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix3x4fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glProgramUniformMatrix4x3fvEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glProgramUniformMatrix4x3fvEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexPageCommitmentEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, commit, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLboolean]
        cfunc = c.glTexPageCommitmentEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, level, xoffset, yoffset, zoffset, width, height, depth, commit)
    # Check if the function actually exists
    f = c.glTexPageCommitmentEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPatchParameteriEXT(pname, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint]
        cfunc = c.glPatchParameteriEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pname, value)
    # Check if the function actually exists
    f = c.glPatchParameteriEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexParameterIivEXT(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLint]
        cfunc = c.glTexParameterIivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glTexParameterIivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexParameterIuivEXT(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint]
        cfunc = c.glTexParameterIuivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glTexParameterIuivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetTexParameterIivEXT(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLint]
        cfunc = c.glGetTexParameterIivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glGetTexParameterIivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetTexParameterIuivEXT(target, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint]
        cfunc = c.glGetTexParameterIuivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param0)
    # Check if the function actually exists
    f = c.glGetTexParameterIuivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glSamplerParameterIivEXT(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glSamplerParameterIivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glSamplerParameterIivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glSamplerParameterIuivEXT(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint]
        cfunc = c.glSamplerParameterIuivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glSamplerParameterIuivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetSamplerParameterIivEXT(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glGetSamplerParameterIivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glGetSamplerParameterIivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetSamplerParameterIuivEXT(sampler, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint]
        cfunc = c.glGetSamplerParameterIuivEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(sampler, pname, param0)
    # Check if the function actually exists
    f = c.glGetSamplerParameterIuivEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexBufferEXT(target, internalformat, buffer, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint]
        cfunc = c.glTexBufferEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, internalformat, buffer)
    # Check if the function actually exists
    f = c.glTexBufferEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexBufferRangeEXT(target, internalformat, buffer, offset, size, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint, GLintptr, GLsizeiptr]
        cfunc = c.glTexBufferRangeEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, internalformat, buffer, offset, size)
    # Check if the function actually exists
    f = c.glTexBufferRangeEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexStorage1DEXT(target, levels, internalformat, width, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei]
        cfunc = c.glTexStorage1DEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, levels, internalformat, width)
    # Check if the function actually exists
    f = c.glTexStorage1DEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexStorage2DEXT(target, levels, internalformat, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei]
        cfunc = c.glTexStorage2DEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, levels, internalformat, width, height)
    # Check if the function actually exists
    f = c.glTexStorage2DEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTexStorage3DEXT(target, levels, internalformat, width, height, depth, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei]
        cfunc = c.glTexStorage3DEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, levels, internalformat, width, height, depth)
    # Check if the function actually exists
    f = c.glTexStorage3DEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTextureStorage1DEXT(texture, target, levels, internalformat, width, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLsizei, GLenum, GLsizei]
        cfunc = c.glTextureStorage1DEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, target, levels, internalformat, width)
    # Check if the function actually exists
    f = c.glTextureStorage1DEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTextureStorage2DEXT(texture, target, levels, internalformat, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei]
        cfunc = c.glTextureStorage2DEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, target, levels, internalformat, width, height)
    # Check if the function actually exists
    f = c.glTextureStorage2DEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei]
        cfunc = c.glTextureStorage3DEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, target, levels, internalformat, width, height, depth)
    # Check if the function actually exists
    f = c.glTextureStorage3DEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint, GLenum, GLuint, GLuint, GLuint, GLuint]
        cfunc = c.glTextureViewEXT
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)
    # Check if the function actually exists
    f = c.glTextureViewEXT
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei]
        cfunc = c.glRenderbufferStorageMultisampleIMG
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, samples, internalformat, width, height)
    # Check if the function actually exists
    f = c.glRenderbufferStorageMultisampleIMG
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLenum, GLuint, GLint, GLsizei]
        cfunc = c.glFramebufferTexture2DMultisampleIMG
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, attachment, textarget, texture, level, samples)
    # Check if the function actually exists
    f = c.glFramebufferTexture2DMultisampleIMG
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glApplyFramebufferAttachmentCMAAINTEL(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glApplyFramebufferAttachmentCMAAINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glApplyFramebufferAttachmentCMAAINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBeginPerfQueryINTEL(queryHandle, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glBeginPerfQueryINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryHandle)
    # Check if the function actually exists
    f = c.glBeginPerfQueryINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCreatePerfQueryINTEL(queryId, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glCreatePerfQueryINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryId, param0)
    # Check if the function actually exists
    f = c.glCreatePerfQueryINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDeletePerfQueryINTEL(queryHandle, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glDeletePerfQueryINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryHandle)
    # Check if the function actually exists
    f = c.glDeletePerfQueryINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEndPerfQueryINTEL(queryHandle, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glEndPerfQueryINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryHandle)
    # Check if the function actually exists
    f = c.glEndPerfQueryINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetFirstPerfQueryIdINTEL(param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glGetFirstPerfQueryIdINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0)
    # Check if the function actually exists
    f = c.glGetFirstPerfQueryIdINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetNextPerfQueryIdINTEL(queryId, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glGetNextPerfQueryIdINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryId, param0)
    # Check if the function actually exists
    f = c.glGetNextPerfQueryIdINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, param0, counterDescLength, param1, param2, param3, param4, param5, param6, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLuint, GLchar, GLuint, GLchar, GLuint, GLuint, GLuint, GLuint, GLuint64]
        cfunc = c.glGetPerfCounterInfoINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryId, counterId, counterNameLength, param0, counterDescLength, param1, param2, param3, param4, param5, param6)
    # Check if the function actually exists
    f = c.glGetPerfCounterInfoINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLsizei, GLvoid, GLuint]
        cfunc = c.glGetPerfQueryDataINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryHandle, flags, dataSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetPerfQueryDataINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfQueryIdByNameINTEL(param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLchar, GLuint]
        cfunc = c.glGetPerfQueryIdByNameINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, param1)
    # Check if the function actually exists
    f = c.glGetPerfQueryIdByNameINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPerfQueryInfoINTEL(queryId, queryNameLength, param0, param1, param2, param3, param4, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLchar, GLuint, GLuint, GLuint, GLuint]
        cfunc = c.glGetPerfQueryInfoINTEL
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(queryId, queryNameLength, param0, param1, param2, param3, param4)
    # Check if the function actually exists
    f = c.glGetPerfQueryInfoINTEL
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetTextureHandleNV(texture, argtypes_p=None):
        restype = GLuint64
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glGetTextureHandleNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture)
    # Check if the function actually exists
    f = c.glGetTextureHandleNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetTextureSamplerHandleNV(texture, sampler, argtypes_p=None):
        restype = GLuint64
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glGetTextureSamplerHandleNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, sampler)
    # Check if the function actually exists
    f = c.glGetTextureSamplerHandleNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMakeTextureHandleResidentNV(handle, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint64]
        cfunc = c.glMakeTextureHandleResidentNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(handle)
    # Check if the function actually exists
    f = c.glMakeTextureHandleResidentNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMakeTextureHandleNonResidentNV(handle, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint64]
        cfunc = c.glMakeTextureHandleNonResidentNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(handle)
    # Check if the function actually exists
    f = c.glMakeTextureHandleNonResidentNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetImageHandleNV(texture, level, layered, layer, format, argtypes_p=None):
        restype = GLuint64
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLboolean, GLint, GLenum]
        cfunc = c.glGetImageHandleNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, level, layered, layer, format)
    # Check if the function actually exists
    f = c.glGetImageHandleNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMakeImageHandleResidentNV(handle, access, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint64, GLenum]
        cfunc = c.glMakeImageHandleResidentNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(handle, access)
    # Check if the function actually exists
    f = c.glMakeImageHandleResidentNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMakeImageHandleNonResidentNV(handle, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint64]
        cfunc = c.glMakeImageHandleNonResidentNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(handle)
    # Check if the function actually exists
    f = c.glMakeImageHandleNonResidentNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformHandleui64NV(location, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLuint64]
        cfunc = c.glUniformHandleui64NV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, value)
    # Check if the function actually exists
    f = c.glUniformHandleui64NV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformHandleui64vNV(location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLuint64]
        cfunc = c.glUniformHandleui64vNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, count, param0)
    # Check if the function actually exists
    f = c.glUniformHandleui64vNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformHandleui64NV(program, location, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLuint64]
        cfunc = c.glProgramUniformHandleui64NV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, value)
    # Check if the function actually exists
    f = c.glProgramUniformHandleui64NV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramUniformHandleui64vNV(program, location, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLsizei, GLuint64]
        cfunc = c.glProgramUniformHandleui64vNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, count, param0)
    # Check if the function actually exists
    f = c.glProgramUniformHandleui64vNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsTextureHandleResidentNV(handle, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint64]
        cfunc = c.glIsTextureHandleResidentNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(handle)
    # Check if the function actually exists
    f = c.glIsTextureHandleResidentNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsImageHandleResidentNV(handle, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint64]
        cfunc = c.glIsImageHandleResidentNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(handle)
    # Check if the function actually exists
    f = c.glIsImageHandleResidentNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendParameteriNV(pname, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint]
        cfunc = c.glBlendParameteriNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pname, value)
    # Check if the function actually exists
    f = c.glBlendParameteriNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlendBarrierNV(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glBlendBarrierNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glBlendBarrierNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBeginConditionalRenderNV(id, mode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum]
        cfunc = c.glBeginConditionalRenderNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(id, mode)
    # Check if the function actually exists
    f = c.glBeginConditionalRenderNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEndConditionalRenderNV(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glEndConditionalRenderNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glEndConditionalRenderNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glSubpixelPrecisionBiasNV(xbits, ybits, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glSubpixelPrecisionBiasNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(xbits, ybits)
    # Check if the function actually exists
    f = c.glSubpixelPrecisionBiasNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCopyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr]
        cfunc = c.glCopyBufferSubDataNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(readTarget, writeTarget, readOffset, writeOffset, size)
    # Check if the function actually exists
    f = c.glCopyBufferSubDataNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverageMaskNV(mask, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLboolean]
        cfunc = c.glCoverageMaskNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mask)
    # Check if the function actually exists
    f = c.glCoverageMaskNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverageOperationNV(operation, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum]
        cfunc = c.glCoverageOperationNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(operation)
    # Check if the function actually exists
    f = c.glCoverageOperationNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawBuffersNV(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum]
        cfunc = c.glDrawBuffersNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glDrawBuffersNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawArraysInstancedNV(mode, first, count, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLsizei, GLsizei]
        cfunc = c.glDrawArraysInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, first, count, primcount)
    # Check if the function actually exists
    f = c.glDrawArraysInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDrawElementsInstancedNV(mode, count, type, voidindices, primcount, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLsizei]
        cfunc = c.glDrawElementsInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode, count, type, voidindices, primcount)
    # Check if the function actually exists
    f = c.glDrawElementsInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDeleteFencesNV(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glDeleteFencesNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glDeleteFencesNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGenFencesNV(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLuint]
        cfunc = c.glGenFencesNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glGenFencesNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsFenceNV(fence, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glIsFenceNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(fence)
    # Check if the function actually exists
    f = c.glIsFenceNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTestFenceNV(fence, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glTestFenceNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(fence)
    # Check if the function actually exists
    f = c.glTestFenceNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetFenceivNV(fence, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glGetFenceivNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(fence, pname, param0)
    # Check if the function actually exists
    f = c.glGetFenceivNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFinishFenceNV(fence, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glFinishFenceNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(fence)
    # Check if the function actually exists
    f = c.glFinishFenceNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glSetFenceNV(fence, condition, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum]
        cfunc = c.glSetFenceNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(fence, condition)
    # Check if the function actually exists
    f = c.glSetFenceNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFragmentCoverageColorNV(color, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glFragmentCoverageColorNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(color)
    # Check if the function actually exists
    f = c.glFragmentCoverageColorNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum]
        cfunc = c.glBlitFramebufferNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    # Check if the function actually exists
    f = c.glBlitFramebufferNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverageModulationTableNV(n, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLfloat]
        cfunc = c.glCoverageModulationTableNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(n, param0)
    # Check if the function actually exists
    f = c.glCoverageModulationTableNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetCoverageModulationTableNV(bufsize, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLfloat]
        cfunc = c.glGetCoverageModulationTableNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(bufsize, param0)
    # Check if the function actually exists
    f = c.glGetCoverageModulationTableNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverageModulationNV(components, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum]
        cfunc = c.glCoverageModulationNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(components)
    # Check if the function actually exists
    f = c.glCoverageModulationNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glRenderbufferStorageMultisampleNV(target, samples, internalformat, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, GLsizei, GLsizei]
        cfunc = c.glRenderbufferStorageMultisampleNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, samples, internalformat, width, height)
    # Check if the function actually exists
    f = c.glRenderbufferStorageMultisampleNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glVertexAttribDivisorNV(index, divisor, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glVertexAttribDivisorNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, divisor)
    # Check if the function actually exists
    f = c.glVertexAttribDivisorNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLsizei, GLenum, GLsizei, GLint]
        cfunc = c.glGetInternalformatSampleivNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, internalformat, samples, pname, bufSize, param0)
    # Check if the function actually exists
    f = c.glGetInternalformatSampleivNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformMatrix2x3fvNV(location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glUniformMatrix2x3fvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glUniformMatrix2x3fvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformMatrix3x2fvNV(location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glUniformMatrix3x2fvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glUniformMatrix3x2fvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformMatrix2x4fvNV(location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glUniformMatrix2x4fvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glUniformMatrix2x4fvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformMatrix4x2fvNV(location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glUniformMatrix4x2fvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glUniformMatrix4x2fvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformMatrix3x4fvNV(location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glUniformMatrix3x4fvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glUniformMatrix3x4fvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glUniformMatrix4x3fvNV(location, count, transpose, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLboolean, GLfloat]
        cfunc = c.glUniformMatrix4x3fvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(location, count, transpose, param0)
    # Check if the function actually exists
    f = c.glUniformMatrix4x3fvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGenPathsNV(range, argtypes_p=None):
        restype = GLuint
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei]
        cfunc = c.glGenPathsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(range)
    # Check if the function actually exists
    f = c.glGenPathsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDeletePathsNV(path, range, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei]
        cfunc = c.glDeletePathsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, range)
    # Check if the function actually exists
    f = c.glDeletePathsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsPathNV(path, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glIsPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path)
    # Check if the function actually exists
    f = c.glIsPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathCommandsNV(path, numCommands, param0, numCoords, coordType, voidcoords, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLubyte, GLsizei, GLenum, ctypes.c_void_p]
        cfunc = c.glPathCommandsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, numCommands, param0, numCoords, coordType, voidcoords)
    # Check if the function actually exists
    f = c.glPathCommandsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathCoordsNV(path, numCoords, coordType, voidcoords, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLenum, ctypes.c_void_p]
        cfunc = c.glPathCoordsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, numCoords, coordType, voidcoords)
    # Check if the function actually exists
    f = c.glPathCoordsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, param0, numCoords, coordType, voidcoords, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLsizei, GLubyte, GLsizei, GLenum, ctypes.c_void_p]
        cfunc = c.glPathSubCommandsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, commandStart, commandsToDelete, numCommands, param0, numCoords, coordType, voidcoords)
    # Check if the function actually exists
    f = c.glPathSubCommandsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathSubCoordsNV(path, coordStart, numCoords, coordType, voidcoords, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLenum, ctypes.c_void_p]
        cfunc = c.glPathSubCoordsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, coordStart, numCoords, coordType, voidcoords)
    # Check if the function actually exists
    f = c.glPathSubCoordsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathStringNV(path, format, length, voidpathString, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLsizei, ctypes.c_void_p]
        cfunc = c.glPathStringNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, format, length, voidpathString)
    # Check if the function actually exists
    f = c.glPathStringNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathGlyphsNV(firstPathName, fontTarget, voidfontName, fontStyle, numGlyphs, type, voidcharcodes, handleMissingGlyphs, pathParameterTemplate, emScale, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, ctypes.c_void_p, GLbitfield, GLsizei, GLenum, ctypes.c_void_p, GLenum, GLuint, GLfloat]
        cfunc = c.glPathGlyphsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(firstPathName, fontTarget, voidfontName, fontStyle, numGlyphs, type, voidcharcodes, handleMissingGlyphs, pathParameterTemplate, emScale)
    # Check if the function actually exists
    f = c.glPathGlyphsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathGlyphRangeNV(firstPathName, fontTarget, voidfontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, ctypes.c_void_p, GLbitfield, GLuint, GLsizei, GLenum, GLuint, GLfloat]
        cfunc = c.glPathGlyphRangeNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(firstPathName, fontTarget, voidfontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale)
    # Check if the function actually exists
    f = c.glPathGlyphRangeNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glWeightPathsNV(resultPath, numPaths, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLuint, GLfloat]
        cfunc = c.glWeightPathsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(resultPath, numPaths, param0, param1)
    # Check if the function actually exists
    f = c.glWeightPathsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCopyPathNV(resultPath, srcPath, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint]
        cfunc = c.glCopyPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(resultPath, srcPath)
    # Check if the function actually exists
    f = c.glCopyPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glInterpolatePathsNV(resultPath, pathA, pathB, weight, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLuint, GLfloat]
        cfunc = c.glInterpolatePathsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(resultPath, pathA, pathB, weight)
    # Check if the function actually exists
    f = c.glInterpolatePathsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glTransformPathNV(resultPath, srcPath, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLenum, GLfloat]
        cfunc = c.glTransformPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(resultPath, srcPath, transformType, param0)
    # Check if the function actually exists
    f = c.glTransformPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathParameterivNV(path, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glPathParameterivNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, pname, param0)
    # Check if the function actually exists
    f = c.glPathParameterivNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathParameteriNV(path, pname, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glPathParameteriNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, pname, value)
    # Check if the function actually exists
    f = c.glPathParameteriNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathParameterfvNV(path, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLfloat]
        cfunc = c.glPathParameterfvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, pname, param0)
    # Check if the function actually exists
    f = c.glPathParameterfvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathParameterfNV(path, pname, value, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLfloat]
        cfunc = c.glPathParameterfNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, pname, value)
    # Check if the function actually exists
    f = c.glPathParameterfNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathDashArrayNV(path, dashCount, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLfloat]
        cfunc = c.glPathDashArrayNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, dashCount, param0)
    # Check if the function actually exists
    f = c.glPathDashArrayNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathStencilFuncNV(func, ref, mask, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLuint]
        cfunc = c.glPathStencilFuncNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(func, ref, mask)
    # Check if the function actually exists
    f = c.glPathStencilFuncNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathStencilDepthOffsetNV(factor, units, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLfloat, GLfloat]
        cfunc = c.glPathStencilDepthOffsetNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(factor, units)
    # Check if the function actually exists
    f = c.glPathStencilDepthOffsetNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilFillPathNV(path, fillMode, mask, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint]
        cfunc = c.glStencilFillPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, fillMode, mask)
    # Check if the function actually exists
    f = c.glStencilFillPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilStrokePathNV(path, reference, mask, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLuint]
        cfunc = c.glStencilStrokePathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, reference, mask)
    # Check if the function actually exists
    f = c.glStencilStrokePathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilFillPathInstancedNV(numPaths, pathNameType, voidpaths, pathBase, fillMode, mask, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum, ctypes.c_void_p, GLuint, GLenum, GLuint, GLenum, GLfloat]
        cfunc = c.glStencilFillPathInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(numPaths, pathNameType, voidpaths, pathBase, fillMode, mask, transformType, param0)
    # Check if the function actually exists
    f = c.glStencilFillPathInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilStrokePathInstancedNV(numPaths, pathNameType, voidpaths, pathBase, reference, mask, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum, ctypes.c_void_p, GLuint, GLint, GLuint, GLenum, GLfloat]
        cfunc = c.glStencilStrokePathInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(numPaths, pathNameType, voidpaths, pathBase, reference, mask, transformType, param0)
    # Check if the function actually exists
    f = c.glStencilStrokePathInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathCoverDepthFuncNV(func, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum]
        cfunc = c.glPathCoverDepthFuncNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(func)
    # Check if the function actually exists
    f = c.glPathCoverDepthFuncNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverFillPathNV(path, coverMode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum]
        cfunc = c.glCoverFillPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, coverMode)
    # Check if the function actually exists
    f = c.glCoverFillPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverStrokePathNV(path, coverMode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum]
        cfunc = c.glCoverStrokePathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, coverMode)
    # Check if the function actually exists
    f = c.glCoverStrokePathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverFillPathInstancedNV(numPaths, pathNameType, voidpaths, pathBase, coverMode, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum, ctypes.c_void_p, GLuint, GLenum, GLenum, GLfloat]
        cfunc = c.glCoverFillPathInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(numPaths, pathNameType, voidpaths, pathBase, coverMode, transformType, param0)
    # Check if the function actually exists
    f = c.glCoverFillPathInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glCoverStrokePathInstancedNV(numPaths, pathNameType, voidpaths, pathBase, coverMode, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum, ctypes.c_void_p, GLuint, GLenum, GLenum, GLfloat]
        cfunc = c.glCoverStrokePathInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(numPaths, pathNameType, voidpaths, pathBase, coverMode, transformType, param0)
    # Check if the function actually exists
    f = c.glCoverStrokePathInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathParameterivNV(path, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint]
        cfunc = c.glGetPathParameterivNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, pname, param0)
    # Check if the function actually exists
    f = c.glGetPathParameterivNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathParameterfvNV(path, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLfloat]
        cfunc = c.glGetPathParameterfvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, pname, param0)
    # Check if the function actually exists
    f = c.glGetPathParameterfvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathCommandsNV(path, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLubyte]
        cfunc = c.glGetPathCommandsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, param0)
    # Check if the function actually exists
    f = c.glGetPathCommandsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathCoordsNV(path, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLfloat]
        cfunc = c.glGetPathCoordsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, param0)
    # Check if the function actually exists
    f = c.glGetPathCoordsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathDashArrayNV(path, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLfloat]
        cfunc = c.glGetPathDashArrayNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, param0)
    # Check if the function actually exists
    f = c.glGetPathDashArrayNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, voidpaths, pathBase, stride, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLbitfield, GLsizei, GLenum, ctypes.c_void_p, GLuint, GLsizei, GLfloat]
        cfunc = c.glGetPathMetricsNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(metricQueryMask, numPaths, pathNameType, voidpaths, pathBase, stride, param0)
    # Check if the function actually exists
    f = c.glGetPathMetricsNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLbitfield, GLuint, GLsizei, GLsizei, GLfloat]
        cfunc = c.glGetPathMetricRangeNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(metricQueryMask, firstPathName, numPaths, stride, param0)
    # Check if the function actually exists
    f = c.glGetPathMetricRangeNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathSpacingNV(pathListMode, numPaths, pathNameType, voidpaths, pathBase, advanceScale, kerningScale, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLsizei, GLenum, ctypes.c_void_p, GLuint, GLfloat, GLfloat, GLenum, GLfloat]
        cfunc = c.glGetPathSpacingNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(pathListMode, numPaths, pathNameType, voidpaths, pathBase, advanceScale, kerningScale, transformType, param0)
    # Check if the function actually exists
    f = c.glGetPathSpacingNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsPointInFillPathNV(path, mask, x, y, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLfloat, GLfloat]
        cfunc = c.glIsPointInFillPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, mask, x, y)
    # Check if the function actually exists
    f = c.glIsPointInFillPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsPointInStrokePathNV(path, x, y, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLfloat, GLfloat]
        cfunc = c.glIsPointInStrokePathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, x, y)
    # Check if the function actually exists
    f = c.glIsPointInStrokePathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetPathLengthNV(path, startSegment, numSegments, argtypes_p=None):
        restype = GLfloat
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei]
        cfunc = c.glGetPathLengthNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, startSegment, numSegments)
    # Check if the function actually exists
    f = c.glGetPathLengthNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPointAlongPathNV(path, startSegment, numSegments, distance, param0, param1, param2, param3, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat]
        cfunc = c.glPointAlongPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, startSegment, numSegments, distance, param0, param1, param2, param3)
    # Check if the function actually exists
    f = c.glPointAlongPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMatrixLoad3x2fNV(matrixMode, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLfloat]
        cfunc = c.glMatrixLoad3x2fNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(matrixMode, param0)
    # Check if the function actually exists
    f = c.glMatrixLoad3x2fNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMatrixLoad3x3fNV(matrixMode, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLfloat]
        cfunc = c.glMatrixLoad3x3fNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(matrixMode, param0)
    # Check if the function actually exists
    f = c.glMatrixLoad3x3fNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMatrixLoadTranspose3x3fNV(matrixMode, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLfloat]
        cfunc = c.glMatrixLoadTranspose3x3fNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(matrixMode, param0)
    # Check if the function actually exists
    f = c.glMatrixLoadTranspose3x3fNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMatrixMult3x2fNV(matrixMode, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLfloat]
        cfunc = c.glMatrixMult3x2fNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(matrixMode, param0)
    # Check if the function actually exists
    f = c.glMatrixMult3x2fNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMatrixMult3x3fNV(matrixMode, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLfloat]
        cfunc = c.glMatrixMult3x3fNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(matrixMode, param0)
    # Check if the function actually exists
    f = c.glMatrixMult3x3fNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glMatrixMultTranspose3x3fNV(matrixMode, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLfloat]
        cfunc = c.glMatrixMultTranspose3x3fNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(matrixMode, param0)
    # Check if the function actually exists
    f = c.glMatrixMultTranspose3x3fNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint, GLenum]
        cfunc = c.glStencilThenCoverFillPathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, fillMode, mask, coverMode)
    # Check if the function actually exists
    f = c.glStencilThenCoverFillPathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilThenCoverStrokePathNV(path, reference, mask, coverMode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLuint, GLenum]
        cfunc = c.glStencilThenCoverStrokePathNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(path, reference, mask, coverMode)
    # Check if the function actually exists
    f = c.glStencilThenCoverStrokePathNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, voidpaths, pathBase, fillMode, mask, coverMode, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum, ctypes.c_void_p, GLuint, GLenum, GLuint, GLenum, GLenum, GLfloat]
        cfunc = c.glStencilThenCoverFillPathInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(numPaths, pathNameType, voidpaths, pathBase, fillMode, mask, coverMode, transformType, param0)
    # Check if the function actually exists
    f = c.glStencilThenCoverFillPathInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, voidpaths, pathBase, reference, mask, coverMode, transformType, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLsizei, GLenum, ctypes.c_void_p, GLuint, GLint, GLuint, GLenum, GLenum, GLfloat]
        cfunc = c.glStencilThenCoverStrokePathInstancedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(numPaths, pathNameType, voidpaths, pathBase, reference, mask, coverMode, transformType, param0)
    # Check if the function actually exists
    f = c.glStencilThenCoverStrokePathInstancedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathGlyphIndexRangeNV(fontTarget, voidfontName, fontStyle, pathParameterTemplate, emScale, baseAndCount, argtypes_p=None):
        restype = GLenum
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, ctypes.c_void_p, GLbitfield, GLuint, GLfloat, (GLuint * 2)]
        cfunc = c.glPathGlyphIndexRangeNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(fontTarget, voidfontName, fontStyle, pathParameterTemplate, emScale, baseAndCount)
    # Check if the function actually exists
    f = c.glPathGlyphIndexRangeNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathGlyphIndexArrayNV(firstPathName, fontTarget, voidfontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale, argtypes_p=None):
        restype = GLenum
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, ctypes.c_void_p, GLbitfield, GLuint, GLsizei, GLuint, GLfloat]
        cfunc = c.glPathGlyphIndexArrayNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(firstPathName, fontTarget, voidfontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale)
    # Check if the function actually exists
    f = c.glPathGlyphIndexArrayNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, voidfontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale, argtypes_p=None):
        restype = GLenum
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLsizeiptr, ctypes.c_void_p, GLsizei, GLuint, GLsizei, GLuint, GLfloat]
        cfunc = c.glPathMemoryGlyphIndexArrayNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(firstPathName, fontTarget, fontSize, voidfontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale)
    # Check if the function actually exists
    f = c.glPathMemoryGlyphIndexArrayNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glProgramPathFragmentInputGenNV(program, location, genMode, components, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLenum, GLint, GLfloat]
        cfunc = c.glProgramPathFragmentInputGenNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, location, genMode, components, param0)
    # Check if the function actually exists
    f = c.glProgramPathFragmentInputGenNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetProgramResourcefvNV(program, programInterface, index, propCount, param0, bufSize, param1, param2, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLfloat]
        cfunc = c.glGetProgramResourcefvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, programInterface, index, propCount, param0, bufSize, param1, param2)
    # Check if the function actually exists
    f = c.glGetProgramResourcefvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glPolygonModeNV(face, mode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum]
        cfunc = c.glPolygonModeNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(face, mode)
    # Check if the function actually exists
    f = c.glPolygonModeNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glReadBufferNV(mode, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum]
        cfunc = c.glReadBufferNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(mode)
    # Check if the function actually exists
    f = c.glReadBufferNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFramebufferSampleLocationsfvNV(target, start, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLsizei, GLfloat]
        cfunc = c.glFramebufferSampleLocationsfvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, start, count, param0)
    # Check if the function actually exists
    f = c.glFramebufferSampleLocationsfvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLsizei, GLfloat]
        cfunc = c.glNamedFramebufferSampleLocationsfvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(framebuffer, start, count, param0)
    # Check if the function actually exists
    f = c.glNamedFramebufferSampleLocationsfvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glResolveDepthValuesNV(void, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [ctypes.c_void_p]
        cfunc = c.glResolveDepthValuesNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(void)
    # Check if the function actually exists
    f = c.glResolveDepthValuesNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glViewportArrayvNV(first, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLfloat]
        cfunc = c.glViewportArrayvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(first, count, param0)
    # Check if the function actually exists
    f = c.glViewportArrayvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glViewportIndexedfNV(index, x, y, w, h, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLfloat, GLfloat, GLfloat, GLfloat]
        cfunc = c.glViewportIndexedfNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, x, y, w, h)
    # Check if the function actually exists
    f = c.glViewportIndexedfNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glViewportIndexedfvNV(index, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLfloat]
        cfunc = c.glViewportIndexedfvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, param0)
    # Check if the function actually exists
    f = c.glViewportIndexedfvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glScissorArrayvNV(first, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLint]
        cfunc = c.glScissorArrayvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(first, count, param0)
    # Check if the function actually exists
    f = c.glScissorArrayvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glScissorIndexedNV(index, left, bottom, width, height, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint, GLsizei, GLsizei]
        cfunc = c.glScissorIndexedNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, left, bottom, width, height)
    # Check if the function actually exists
    f = c.glScissorIndexedNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glScissorIndexedvNV(index, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint]
        cfunc = c.glScissorIndexedvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, param0)
    # Check if the function actually exists
    f = c.glScissorIndexedvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDepthRangeArrayfvNV(first, count, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLfloat]
        cfunc = c.glDepthRangeArrayfvNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(first, count, param0)
    # Check if the function actually exists
    f = c.glDepthRangeArrayfvNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDepthRangeIndexedfNV(index, n, f, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLfloat, GLfloat]
        cfunc = c.glDepthRangeIndexedfNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(index, n, f)
    # Check if the function actually exists
    f = c.glDepthRangeIndexedfNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetFloati_vNV(target, index, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint, GLfloat]
        cfunc = c.glGetFloati_vNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index, param0)
    # Check if the function actually exists
    f = c.glGetFloati_vNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEnableiNV(target, index, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glEnableiNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glEnableiNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDisableiNV(target, index, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glDisableiNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glDisableiNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glIsEnablediNV(target, index, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLuint]
        cfunc = c.glIsEnablediNV
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, index)
    # Check if the function actually exists
    f = c.glIsEnablediNV
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glFramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLuint, GLint, GLint, GLsizei]
        cfunc = c.glFramebufferTextureMultiviewOVR
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, attachment, texture, level, baseViewIndex, numViews)
    # Check if the function actually exists
    f = c.glFramebufferTextureMultiviewOVR
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glAlphaFuncQCOM(func, ref, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLclampf]
        cfunc = c.glAlphaFuncQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(func, ref)
    # Check if the function actually exists
    f = c.glAlphaFuncQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetDriverControlsQCOM(param0, size, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLint, GLsizei, GLuint]
        cfunc = c.glGetDriverControlsQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, size, param1)
    # Check if the function actually exists
    f = c.glGetDriverControlsQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glGetDriverControlStringQCOM(driverControl, bufSize, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLsizei, GLsizei, GLchar]
        cfunc = c.glGetDriverControlStringQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(driverControl, bufSize, param0, param1)
    # Check if the function actually exists
    f = c.glGetDriverControlStringQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEnableDriverControlQCOM(driverControl, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glEnableDriverControlQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(driverControl)
    # Check if the function actually exists
    f = c.glEnableDriverControlQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glDisableDriverControlQCOM(driverControl, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glDisableDriverControlQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(driverControl)
    # Check if the function actually exists
    f = c.glDisableDriverControlQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetTexturesQCOM(param0, maxTextures, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint]
        cfunc = c.glExtGetTexturesQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, maxTextures, param1)
    # Check if the function actually exists
    f = c.glExtGetTexturesQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetBuffersQCOM(param0, maxBuffers, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint]
        cfunc = c.glExtGetBuffersQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, maxBuffers, param1)
    # Check if the function actually exists
    f = c.glExtGetBuffersQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetRenderbuffersQCOM(param0, maxRenderbuffers, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint]
        cfunc = c.glExtGetRenderbuffersQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, maxRenderbuffers, param1)
    # Check if the function actually exists
    f = c.glExtGetRenderbuffersQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetFramebuffersQCOM(param0, maxFramebuffers, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint]
        cfunc = c.glExtGetFramebuffersQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, maxFramebuffers, param1)
    # Check if the function actually exists
    f = c.glExtGetFramebuffersQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetTexLevelParameterivQCOM(texture, face, level, pname, param0, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLint, GLenum, GLint]
        cfunc = c.glExtGetTexLevelParameterivQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(texture, face, level, pname, param0)
    # Check if the function actually exists
    f = c.glExtGetTexLevelParameterivQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtTexObjectStateOverrideiQCOM(target, pname, param, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLenum, GLint]
        cfunc = c.glExtTexObjectStateOverrideiQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, pname, param)
    # Check if the function actually exists
    f = c.glExtTexObjectStateOverrideiQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, voidtexels, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, ctypes.c_void_p]
        cfunc = c.glExtGetTexSubImageQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, voidtexels)
    # Check if the function actually exists
    f = c.glExtGetTexSubImageQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetBufferPointervQCOM(target, voidparams, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLenum, ctypes.c_void_p]
        cfunc = c.glExtGetBufferPointervQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(target, voidparams)
    # Check if the function actually exists
    f = c.glExtGetBufferPointervQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetShadersQCOM(param0, maxShaders, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint]
        cfunc = c.glExtGetShadersQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, maxShaders, param1)
    # Check if the function actually exists
    f = c.glExtGetShadersQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetProgramsQCOM(param0, maxPrograms, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLint, GLint]
        cfunc = c.glExtGetProgramsQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(param0, maxPrograms, param1)
    # Check if the function actually exists
    f = c.glExtGetProgramsQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtIsProgramBinaryQCOM(program, argtypes_p=None):
        restype = GLboolean
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint]
        cfunc = c.glExtIsProgramBinaryQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program)
    # Check if the function actually exists
    f = c.glExtIsProgramBinaryQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glExtGetProgramBinarySourceQCOM(program, shadertype, param0, param1, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLenum, GLchar, GLint]
        cfunc = c.glExtGetProgramBinarySourceQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(program, shadertype, param0, param1)
    # Check if the function actually exists
    f = c.glExtGetProgramBinarySourceQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glStartTilingQCOM(x, y, width, height, preserveMask, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLuint, GLuint, GLuint, GLuint, GLbitfield]
        cfunc = c.glStartTilingQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(x, y, width, height, preserveMask)
    # Check if the function actually exists
    f = c.glStartTilingQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

try:
    def glEndTilingQCOM(preserveMask, argtypes_p=None):
        restype = None
        if argtypes_p:
            argtypes = argtypes_p
        else:
            argtypes = [GLbitfield]
        cfunc = c.glEndTilingQCOM
        cfunc.restype = restype
        cfunc.argtypes = argtypes
        return cfunc(preserveMask)
    # Check if the function actually exists
    f = c.glEndTilingQCOM
    del f
    loaded[0] += 1
except AttributeError as e:
    loaded[1] += 1
    if DEBUG > 1:
        print 'could not load the function'
        print e

print 'Loaded %i functions and failed to load %i functions of %i functions in the header gl2ext.h' % (loaded[0], loaded[1], sum(loaded))
__all__ = ['glBlendBarrierKHR', 'glDebugMessageControlKHR', 'glDebugMessageInsertKHR', 'glDebugMessageCallbackKHR', 'glGetDebugMessageLogKHR', 'glPushDebugGroupKHR', 'glPopDebugGroupKHR', 'glObjectLabelKHR', 'glGetObjectLabelKHR', 'glObjectPtrLabelKHR', 'glGetObjectPtrLabelKHR', 'glGetPointervKHR', 'glGetGraphicsResetStatusKHR', 'glReadnPixelsKHR', 'glGetnUniformfvKHR', 'glGetnUniformivKHR', 'glGetnUniformuivKHR', 'glEGLImageTargetTexture2DOES', 'glEGLImageTargetRenderbufferStorageOES', 'glCopyImageSubDataOES', 'glEnableiOES', 'glDisableiOES', 'glBlendEquationiOES', 'glBlendEquationSeparateiOES', 'glBlendFunciOES', 'glBlendFuncSeparateiOES', 'glColorMaskiOES', 'glIsEnablediOES', 'glDrawElementsBaseVertexOES', 'glDrawRangeElementsBaseVertexOES', 'glDrawElementsInstancedBaseVertexOES', 'glMultiDrawElementsBaseVertexOES', 'glFramebufferTextureOES', 'glGetProgramBinaryOES', 'glProgramBinaryOES', 'glUnmapBufferOES', 'glGetBufferPointervOES', 'glPrimitiveBoundingBoxOES', 'glMinSampleShadingOES', 'glPatchParameteriOES', 'glTexImage3DOES', 'glTexSubImage3DOES', 'glCopyTexSubImage3DOES', 'glCompressedTexImage3DOES', 'glCompressedTexSubImage3DOES', 'glFramebufferTexture3DOES', 'glTexParameterIivOES', 'glTexParameterIuivOES', 'glGetTexParameterIivOES', 'glGetTexParameterIuivOES', 'glSamplerParameterIivOES', 'glSamplerParameterIuivOES', 'glGetSamplerParameterIivOES', 'glGetSamplerParameterIuivOES', 'glTexBufferOES', 'glTexBufferRangeOES', 'glTexStorage3DMultisampleOES', 'glTextureViewOES', 'glBindVertexArrayOES', 'glDeleteVertexArraysOES', 'glGenVertexArraysOES', 'glIsVertexArrayOES', 'glGetPerfMonitorGroupsAMD', 'glGetPerfMonitorCountersAMD', 'glGetPerfMonitorGroupStringAMD', 'glGetPerfMonitorCounterStringAMD', 'glGetPerfMonitorCounterInfoAMD', 'glGenPerfMonitorsAMD', 'glDeletePerfMonitorsAMD', 'glSelectPerfMonitorCountersAMD', 'glBeginPerfMonitorAMD', 'glEndPerfMonitorAMD', 'glGetPerfMonitorCounterDataAMD', 'glBlitFramebufferANGLE', 'glRenderbufferStorageMultisampleANGLE', 'glDrawArraysInstancedANGLE', 'glDrawElementsInstancedANGLE', 'glVertexAttribDivisorANGLE', 'glGetTranslatedShaderSourceANGLE', 'glCopyTextureLevelsAPPLE', 'glRenderbufferStorageMultisampleAPPLE', 'glResolveMultisampleFramebufferAPPLE', 'glGetInteger64vAPPLE', 'glDrawArraysInstancedBaseInstanceEXT', 'glDrawElementsInstancedBaseInstanceEXT', 'glDrawElementsInstancedBaseVertexBaseInstanceEXT', 'glBindFragDataLocationIndexedEXT', 'glBindFragDataLocationEXT', 'glGetProgramResourceLocationIndexEXT', 'glGetFragDataIndexEXT', 'glBufferStorageEXT', 'glCopyImageSubDataEXT', 'glLabelObjectEXT', 'glGetObjectLabelEXT', 'glInsertEventMarkerEXT', 'glPushGroupMarkerEXT', 'glPopGroupMarkerEXT', 'glDiscardFramebufferEXT', 'glGenQueriesEXT', 'glDeleteQueriesEXT', 'glIsQueryEXT', 'glBeginQueryEXT', 'glEndQueryEXT', 'glQueryCounterEXT', 'glGetQueryivEXT', 'glGetQueryObjectivEXT', 'glGetQueryObjectuivEXT', 'glGetQueryObjecti64vEXT', 'glGetQueryObjectui64vEXT', 'glDrawBuffersEXT', 'glEnableiEXT', 'glDisableiEXT', 'glBlendEquationiEXT', 'glBlendEquationSeparateiEXT', 'glBlendFunciEXT', 'glBlendFuncSeparateiEXT', 'glColorMaskiEXT', 'glIsEnablediEXT', 'glDrawElementsBaseVertexEXT', 'glDrawRangeElementsBaseVertexEXT', 'glDrawElementsInstancedBaseVertexEXT', 'glMultiDrawElementsBaseVertexEXT', 'glDrawArraysInstancedEXT', 'glDrawElementsInstancedEXT', 'glFramebufferTextureEXT', 'glVertexAttribDivisorEXT', 'glFlushMappedBufferRangeEXT', 'glMultiDrawArraysEXT', 'glMultiDrawElementsEXT', 'glMultiDrawArraysIndirectEXT', 'glMultiDrawElementsIndirectEXT', 'glRenderbufferStorageMultisampleEXT', 'glFramebufferTexture2DMultisampleEXT', 'glReadBufferIndexedEXT', 'glDrawBuffersIndexedEXT', 'glGetIntegeri_vEXT', 'glPrimitiveBoundingBoxEXT', 'glRasterSamplesEXT', 'glGetGraphicsResetStatusEXT', 'glReadnPixelsEXT', 'glGetnUniformfvEXT', 'glGetnUniformivEXT', 'glActiveShaderProgramEXT', 'glBindProgramPipelineEXT', 'glCreateShaderProgramvEXT', 'glDeleteProgramPipelinesEXT', 'glGenProgramPipelinesEXT', 'glGetProgramPipelineInfoLogEXT', 'glGetProgramPipelineivEXT', 'glIsProgramPipelineEXT', 'glProgramParameteriEXT', 'glProgramUniform1fEXT', 'glProgramUniform1fvEXT', 'glProgramUniform1iEXT', 'glProgramUniform1ivEXT', 'glProgramUniform2fEXT', 'glProgramUniform2fvEXT', 'glProgramUniform2iEXT', 'glProgramUniform2ivEXT', 'glProgramUniform3fEXT', 'glProgramUniform3fvEXT', 'glProgramUniform3iEXT', 'glProgramUniform3ivEXT', 'glProgramUniform4fEXT', 'glProgramUniform4fvEXT', 'glProgramUniform4iEXT', 'glProgramUniform4ivEXT', 'glProgramUniformMatrix2fvEXT', 'glProgramUniformMatrix3fvEXT', 'glProgramUniformMatrix4fvEXT', 'glUseProgramStagesEXT', 'glValidateProgramPipelineEXT', 'glProgramUniform1uiEXT', 'glProgramUniform2uiEXT', 'glProgramUniform3uiEXT', 'glProgramUniform4uiEXT', 'glProgramUniform1uivEXT', 'glProgramUniform2uivEXT', 'glProgramUniform3uivEXT', 'glProgramUniform4uivEXT', 'glProgramUniformMatrix2x3fvEXT', 'glProgramUniformMatrix3x2fvEXT', 'glProgramUniformMatrix2x4fvEXT', 'glProgramUniformMatrix4x2fvEXT', 'glProgramUniformMatrix3x4fvEXT', 'glProgramUniformMatrix4x3fvEXT', 'glTexPageCommitmentEXT', 'glPatchParameteriEXT', 'glTexParameterIivEXT', 'glTexParameterIuivEXT', 'glGetTexParameterIivEXT', 'glGetTexParameterIuivEXT', 'glSamplerParameterIivEXT', 'glSamplerParameterIuivEXT', 'glGetSamplerParameterIivEXT', 'glGetSamplerParameterIuivEXT', 'glTexBufferEXT', 'glTexBufferRangeEXT', 'glTexStorage1DEXT', 'glTexStorage2DEXT', 'glTexStorage3DEXT', 'glTextureStorage1DEXT', 'glTextureStorage2DEXT', 'glTextureStorage3DEXT', 'glTextureViewEXT', 'glRenderbufferStorageMultisampleIMG', 'glFramebufferTexture2DMultisampleIMG', 'glApplyFramebufferAttachmentCMAAINTEL', 'glBeginPerfQueryINTEL', 'glCreatePerfQueryINTEL', 'glDeletePerfQueryINTEL', 'glEndPerfQueryINTEL', 'glGetFirstPerfQueryIdINTEL', 'glGetNextPerfQueryIdINTEL', 'glGetPerfCounterInfoINTEL', 'glGetPerfQueryDataINTEL', 'glGetPerfQueryIdByNameINTEL', 'glGetPerfQueryInfoINTEL', 'glGetTextureHandleNV', 'glGetTextureSamplerHandleNV', 'glMakeTextureHandleResidentNV', 'glMakeTextureHandleNonResidentNV', 'glGetImageHandleNV', 'glMakeImageHandleResidentNV', 'glMakeImageHandleNonResidentNV', 'glUniformHandleui64NV', 'glUniformHandleui64vNV', 'glProgramUniformHandleui64NV', 'glProgramUniformHandleui64vNV', 'glIsTextureHandleResidentNV', 'glIsImageHandleResidentNV', 'glBlendParameteriNV', 'glBlendBarrierNV', 'glBeginConditionalRenderNV', 'glEndConditionalRenderNV', 'glSubpixelPrecisionBiasNV', 'glCopyBufferSubDataNV', 'glCoverageMaskNV', 'glCoverageOperationNV', 'glDrawBuffersNV', 'glDrawArraysInstancedNV', 'glDrawElementsInstancedNV', 'glDeleteFencesNV', 'glGenFencesNV', 'glIsFenceNV', 'glTestFenceNV', 'glGetFenceivNV', 'glFinishFenceNV', 'glSetFenceNV', 'glFragmentCoverageColorNV', 'glBlitFramebufferNV', 'glCoverageModulationTableNV', 'glGetCoverageModulationTableNV', 'glCoverageModulationNV', 'glRenderbufferStorageMultisampleNV', 'glVertexAttribDivisorNV', 'glGetInternalformatSampleivNV', 'glUniformMatrix2x3fvNV', 'glUniformMatrix3x2fvNV', 'glUniformMatrix2x4fvNV', 'glUniformMatrix4x2fvNV', 'glUniformMatrix3x4fvNV', 'glUniformMatrix4x3fvNV', 'glGenPathsNV', 'glDeletePathsNV', 'glIsPathNV', 'glPathCommandsNV', 'glPathCoordsNV', 'glPathSubCommandsNV', 'glPathSubCoordsNV', 'glPathStringNV', 'glPathGlyphsNV', 'glPathGlyphRangeNV', 'glWeightPathsNV', 'glCopyPathNV', 'glInterpolatePathsNV', 'glTransformPathNV', 'glPathParameterivNV', 'glPathParameteriNV', 'glPathParameterfvNV', 'glPathParameterfNV', 'glPathDashArrayNV', 'glPathStencilFuncNV', 'glPathStencilDepthOffsetNV', 'glStencilFillPathNV', 'glStencilStrokePathNV', 'glStencilFillPathInstancedNV', 'glStencilStrokePathInstancedNV', 'glPathCoverDepthFuncNV', 'glCoverFillPathNV', 'glCoverStrokePathNV', 'glCoverFillPathInstancedNV', 'glCoverStrokePathInstancedNV', 'glGetPathParameterivNV', 'glGetPathParameterfvNV', 'glGetPathCommandsNV', 'glGetPathCoordsNV', 'glGetPathDashArrayNV', 'glGetPathMetricsNV', 'glGetPathMetricRangeNV', 'glGetPathSpacingNV', 'glIsPointInFillPathNV', 'glIsPointInStrokePathNV', 'glGetPathLengthNV', 'glPointAlongPathNV', 'glMatrixLoad3x2fNV', 'glMatrixLoad3x3fNV', 'glMatrixLoadTranspose3x3fNV', 'glMatrixMult3x2fNV', 'glMatrixMult3x3fNV', 'glMatrixMultTranspose3x3fNV', 'glStencilThenCoverFillPathNV', 'glStencilThenCoverStrokePathNV', 'glStencilThenCoverFillPathInstancedNV', 'glStencilThenCoverStrokePathInstancedNV', 'glPathGlyphIndexRangeNV', 'glPathGlyphIndexArrayNV', 'glPathMemoryGlyphIndexArrayNV', 'glProgramPathFragmentInputGenNV', 'glGetProgramResourcefvNV', 'glPolygonModeNV', 'glReadBufferNV', 'glFramebufferSampleLocationsfvNV', 'glNamedFramebufferSampleLocationsfvNV', 'glResolveDepthValuesNV', 'glViewportArrayvNV', 'glViewportIndexedfNV', 'glViewportIndexedfvNV', 'glScissorArrayvNV', 'glScissorIndexedNV', 'glScissorIndexedvNV', 'glDepthRangeArrayfvNV', 'glDepthRangeIndexedfNV', 'glGetFloati_vNV', 'glEnableiNV', 'glDisableiNV', 'glIsEnablediNV', 'glFramebufferTextureMultiviewOVR', 'glAlphaFuncQCOM', 'glGetDriverControlsQCOM', 'glGetDriverControlStringQCOM', 'glEnableDriverControlQCOM', 'glDisableDriverControlQCOM', 'glExtGetTexturesQCOM', 'glExtGetBuffersQCOM', 'glExtGetRenderbuffersQCOM', 'glExtGetFramebuffersQCOM', 'glExtGetTexLevelParameterivQCOM', 'glExtTexObjectStateOverrideiQCOM', 'glExtGetTexSubImageQCOM', 'glExtGetBufferPointervQCOM', 'glExtGetShadersQCOM', 'glExtGetProgramsQCOM', 'glExtIsProgramBinaryQCOM', 'glExtGetProgramBinarySourceQCOM', 'glStartTilingQCOM', 'glEndTilingQCOM', 'GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT', 'GL_RGBA16_EXT', 'GL_GLYPH_WIDTH_BIT_NV', 'GL_MAX_SAMPLES_NV', 'GL_DST_NV', 'GL_OES_packed_depth_stencil', 'GL_TEXTURE_TYPE_QCOM', 'GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT', 'GL_UTF8_NV', 'GL_LUMINANCE4_ALPHA4_OES', 'GL_R11F_G11F_B10F_APPLE', 'GL_DRAW_BUFFER0_EXT', 'GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES', 'GL_OES_standard_derivatives', 'GL_NV_texture_border_clamp', 'GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV', 'GL_NV_non_square_matrices', 'GL_PERFQUERY_COUNTER_RAW_INTEL', 'GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT', 'GL_NV_fbo_color_attachments', 'GL_CONTRAST_NV', 'GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE', 'GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL', 'GL_EXT_sRGB', 'GL_STENCIL_BUFFER_BIT3_QCOM', 'GL_HARDLIGHT_KHR', 'GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV', 'GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG', 'GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES', 'GL_RGBA8_SNORM', 'GL_COMPRESSED_RGBA_ASTC_10x10_KHR', 'GL_DRAW_BUFFER14_EXT', 'GL_RGB32F_EXT', 'GL_PERFQUERY_COUNTER_EVENT_INTEL', 'GL_DISJOINT_NV', 'GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES', 'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR', 'GL_EXT_multisampled_render_to_texture', 'GL_SHADER_BINARY_DMP', 'GL_PATH_GEN_MODE_NV', 'GL_PRIMITIVE_BOUNDING_BOX_EXT', 'GL_PATH_ERROR_POSITION_NV', 'GL_PERFMON_GLOBAL_MODE_QCOM', 'GL_COLOR_ATTACHMENT1_EXT', 'GL_COMPRESSED_RGBA_ASTC_6x5_KHR', 'GL_RELATIVE_LARGE_CW_ARC_TO_NV', 'GL_DRAW_BUFFER13_NV', 'GL_QCOM_tiled_rendering', 'GL_TESS_CONTROL_OUTPUT_VERTICES_OES', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR', 'GL_DRAW_BUFFER6_NV', 'GL_TESS_EVALUATION_SHADER_OES', 'GL_NV_depth_nonlinear', 'GL_RASTER_MULTISAMPLE_EXT', 'GL_EXT_robustness', 'GL_SAMPLER_2D_ARRAY_SHADOW_NV', 'GL_QUERY_BY_REGION_NO_WAIT_NV', 'GL_CONIC_CURVE_TO_NV', 'GL_EXT_shader_pixel_local_storage', 'GL_SMOOTH_CUBIC_CURVE_TO_NV', 'GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV', 'GL_KHR_robustness', 'GL_RESET_NOTIFICATION_STRATEGY_KHR', 'GL_VERTEX_ARRAY_KHR', 'GL_COMPRESSED_RGBA_ASTC_4x4_KHR', 'GL_ANGLE_texture_usage', 'GL_TEXTURE_VIEW_NUM_LEVELS_OES', 'GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT', 'GL_LUMINANCE32F_EXT', 'GL_PALETTE8_R5_G6_B5_OES', 'GL_DEBUG_TYPE_OTHER_KHR', 'GL_OES_compressed_paletted_texture', 'GL_OES_vertex_array_object', 'GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL', 'GL_OES_texture_float_linear', 'GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE', 'GL_EXT_primitive_bounding_box', 'GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES', 'GL_PATH_END_CAPS_NV', 'GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES', 'GL_DRAW_BUFFER15_NV', 'GL_QUADS_OES', 'GL_CLAMP_TO_BORDER_OES', 'GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES', 'GL_STENCIL_INDEX_OES', 'GL_LARGE_CW_ARC_TO_NV', 'GL_ACTIVE_PROGRAM_EXT', 'GL_EXT_texture_compression_s3tc', 'GL_RELATIVE_ROUNDED_RECT2_NV', 'GL_QUERY_RESULT_EXT', 'GL_OES_fragment_precision_high', 'GL_EXT_multi_draw_arrays', 'GL_INT_SAMPLER_BUFFER_OES', 'GL_SYNC_OBJECT_APPLE', 'GL_DRAW_BUFFER7_EXT', 'GL_LINEARDODGE_NV', 'GL_VERTEX_ARRAY_OBJECT_EXT', 'GL_RENDERBUFFER_SAMPLES_NV', 'GL_BOUNDING_BOX_NV', 'GL_ANGLE_depth_texture', 'GL_LINES_ADJACENCY_OES', 'GL_OVR_multiview2', 'GL_COVERAGE_COMPONENT_NV', 'GL_NV_explicit_attrib_location', 'GL_DECODE_EXT', 'GL_COLOR_BUFFER_BIT4_QCOM', 'GL_CLIP_DISTANCE5_APPLE', 'GL_TEXTURE_FORMAT_QCOM', 'GL_CONTEXT_RELEASE_BEHAVIOR_KHR', 'GL_MULTISAMPLE_BUFFER_BIT6_QCOM', 'GL_RELATIVE_SMALL_CW_ARC_TO_NV', 'GL_FONT_X_MAX_BOUNDS_BIT_NV', 'GL_R16F_EXT', 'GL_PERCENTAGE_AMD', 'GL_GEOMETRY_LINKED_INPUT_TYPE_OES', 'GL_STENCIL_INDEX1_OES', 'GL_UNKNOWN_CONTEXT_RESET_KHR', 'GL_TEXTURE_DEPTH_QCOM', 'GL_OES_geometry_point_size', 'GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES', 'GL_VIRTUAL_PAGE_SIZE_Y_EXT', 'GL_NV_framebuffer_blit', 'GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG', 'GL_TRANSLATE_Y_NV', 'GL_BGRA_EXT', 'GL_FRAGMENT_COVERAGE_TO_COLOR_NV', 'GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV', 'GL_UNSIGNED_INT_IMAGE_BUFFER_OES', 'GL_COMPRESSED_RGBA_ASTC_4x4x3_OES', 'GL_FONT_HAS_KERNING_BIT_NV', 'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT', 'GL_GEOMETRY_SHADER_EXT', 'GL_COLOR_ATTACHMENT15_EXT', 'GL_UNDEFINED_VERTEX_EXT', 'GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES', 'GL_FLOAT_MAT2x4_NV', 'GL_PATH_STENCIL_VALUE_MASK_NV', 'GL_ANY_SAMPLES_PASSED_EXT', 'GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR', 'GL_EXT_shader_implicit_conversions', 'GL_EXT_occlusion_query_boolean', 'GL_MAP_PERSISTENT_BIT_EXT', 'GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL', 'GL_TIME_ELAPSED_EXT', 'GL_PATH_STENCIL_FUNC_NV', 'GL_BEVEL_NV', 'GL_KHR_debug', 'GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT', 'GL_SRC_OUT_NV', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR', 'GL_DRAW_BUFFER9_NV', 'GL_EXT_color_buffer_float', 'GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE', 'GL_BUFFER_IMMUTABLE_STORAGE_EXT', 'GL_MAX_TESS_PATCH_COMPONENTS_EXT', 'GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES', 'GL_COVERAGE_MODULATION_NV', 'GL_PROGRAM_PIPELINE_BINDING_EXT', 'GL_IMG_program_binary', 'GL_ARM_mali_program_binary', 'GL_COLOR_ATTACHMENT12_NV', 'GL_TEXTURE_3D_OES', 'GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV', 'GL_BLEND_PREMULTIPLIED_SRC_NV', 'GL_READ_FRAMEBUFFER_NV', 'GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM', 'GL_R16_EXT', 'GL_BUFFER_KHR', 'GL_MAX_SAMPLES_IMG', 'GL_TESS_GEN_SPACING_EXT', 'GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV', 'GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES', 'GL_TESS_CONTROL_SHADER_EXT', 'GL_FENCE_CONDITION_NV', 'GL_SAMPLER_2D_SHADOW_EXT', 'GL_NO_RESET_NOTIFICATION_KHR', 'GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES', 'GL_MULTISAMPLE_BUFFER_BIT5_QCOM', 'GL_OVR_multiview', 'GL_OES_compressed_ETC1_RGB8_texture', 'GL_PALETTE4_R5_G6_B5_OES', 'GL_CONTEXT_LOST_KHR', 'GL_OES_copy_image', 'GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES', 'GL_QCOM_extended_get2', 'GL_PATH_COMMAND_COUNT_NV', 'GL_STACK_UNDERFLOW_KHR', 'GL_DEBUG_GROUP_STACK_DEPTH_KHR', 'GL_TEXTURE_IMMUTABLE_LEVELS', 'GL_PATH_INITIAL_END_CAP_NV', 'GL_DRAW_BUFFER11_NV', 'GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT', 'GL_OES_shader_multisample_interpolation', 'GL_EXT_shadow_samplers', 'GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT', 'GL_SMOOTH_QUADRATIC_CURVE_TO_NV', 'GL_3DC_XY_AMD', 'GL_RELATIVE_QUADRATIC_CURVE_TO_NV', 'GL_NV_viewport_array', 'GL_DIFFERENCE_KHR', 'GL_ALPHA8_EXT', 'GL_EXT_separate_shader_objects', 'GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES', 'GL_COLORBURN_KHR', 'GL_POINT_NV', 'GL_PALETTE8_RGB8_OES', 'GL_ROUND_NV', 'GL_MAX_FRAMEBUFFER_LAYERS_EXT', 'GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV', 'GL_DEPTH_BUFFER_BIT5_QCOM', 'GL_RELATIVE_MOVE_TO_NV', 'GL_SMAPHS30_PROGRAM_BINARY_DMP', 'GL_R32F_EXT', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR', 'GL_VIEWPORT_SUBPIXEL_BITS_NV', 'GL_OES_draw_buffers_indexed', 'GL_DRAW_BUFFER8_EXT', 'GL_POLYGON_OFFSET_LINE_NV', 'GL_SUPERSAMPLE_SCALE_Y_NV', 'GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT', 'GL_RENDERBUFFER_SAMPLES_APPLE', 'GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT', 'GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES', 'GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE', 'GL_OES_sample_variables', 'GL_TEXTURE_BORDER_COLOR_NV', 'GL_SKIP_MISSING_GLYPH_NV', 'GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT', 'GL_IMG_texture_compression_pvrtc2', 'GL_COLOR_ATTACHMENT_EXT', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR', 'GL_FLOAT_MAT3x4_NV', 'GL_OBJECT_TYPE_APPLE', 'GL_PATH_COMPUTED_LENGTH_NV', 'GL_DEBUG_TYPE_PUSH_GROUP_KHR', 'GL_QUERY_OBJECT_EXT', 'GL_STENCIL_BUFFER_BIT5_QCOM', 'GL_PALETTE8_RGBA4_OES', 'GL_TRANSPOSE_AFFINE_2D_NV', 'GL_MOVE_TO_NV', 'GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES', 'GL_TEXTURE_VIEW_NUM_LAYERS_OES', 'GL_NV_conditional_render', 'GL_TEXTURE_VIEW_NUM_LAYERS_EXT', 'GL_MAX_TESS_GEN_LEVEL_OES', 'GL_ANGLE_framebuffer_multisample', 'GL_IS_PER_PATCH_EXT', 'GL_COLOR_ATTACHMENT9_EXT', 'GL_LINE_STRIP_ADJACENCY_EXT', 'GL_PROGRAM_BINARY_FORMATS_OES', 'GL_QCOM_binning_control', 'GL_COLOR_ATTACHMENT11_EXT', 'GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT', 'GL_TESS_CONTROL_SHADER_BIT_EXT', 'GL_EXT_copy_image', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR', 'GL_COVERAGE_EDGE_FRAGMENTS_NV', 'GL_PATH_PROJECTION_STACK_DEPTH_NV', 'GL_AMD_compressed_3DC_texture', 'GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES', 'GL_RGB8_OES', 'GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT', 'GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES', 'GL_MAP_FLUSH_EXPLICIT_BIT_EXT', 'GL_FILE_NAME_NV', 'GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV', 'GL_COUNTER_RANGE_AMD', 'GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT', 'GL_COLOR_ATTACHMENT4_EXT', 'GL_STENCIL_INDEX8_OES', 'GL_COLOR_ATTACHMENT13_EXT', 'GL_COLOR_ATTACHMENT14_NV', 'GL_TEXTURE_BORDER_COLOR_EXT', 'GL_MAP_WRITE_BIT', 'GL_COMPRESSED_RGBA_ASTC_6x6x5_OES', 'GL_NV_image_formats', 'GL_ISOLINES_EXT', 'GL_MAX_DRAW_BUFFERS_NV', 'GL_COLOR_ATTACHMENT6_NV', 'GL_AMD_performance_monitor', 'GL_MAX_TEXTURE_BUFFER_SIZE_OES', 'GL_LUMINANCE_ALPHA32F_EXT', 'GL_FONT_UNINTELLIGIBLE_NV', 'GL_GREEN_NV', 'GL_ALL_SHADER_BITS_EXT', 'GL_PATH_PROJECTION_MATRIX_NV', 'GL_SLUMINANCE_ALPHA_NV', 'GL_EXT_YUV_target', 'GL_SAMPLER_KHR', 'GL_EXT_multiview_draw_buffers', 'GL_UNSIGNED_NORMALIZED_EXT', 'GL_TRIANGLES_ADJACENCY_EXT', 'GL_DEBUG_SOURCE_THIRD_PARTY_KHR', 'GL_RGBA16_SNORM_EXT', 'GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT', 'GL_EXT_shader_integer_mix', 'GL_NV_copy_buffer', 'GL_MINUS_NV', 'GL_EXT_texture_norm16', 'GL_DYNAMIC_STORAGE_BIT_EXT', 'GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT', 'GL_DEPTH_COMPONENT32_OES', 'GL_DRAW_BUFFER8_NV', 'GL_ANGLE_framebuffer_blit', 'GL_SAMPLE_ALPHA_TO_ONE_EXT', 'GL_TEXTURE_VIEW_MIN_LAYER_OES', 'GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT', 'GL_CLIP_DISTANCE4_APPLE', 'GL_COLOR_BUFFER_BIT0_QCOM', 'GL_TIMEOUT_EXPIRED_APPLE', 'GL_UNSIGNED_INT_2_10_10_10_REV_EXT', 'GL_COVERAGE_MODULATION_TABLE_NV', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR', 'GL_ATC_RGB_AMD', 'GL_NV_read_buffer', 'GL_NV_generate_mipmap_sRGB', 'GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV', 'GL_MAX_DRAW_BUFFERS_EXT', 'GL_CONJOINT_NV', 'GL_Z400_BINARY_AMD', 'GL_OES_EGL_image_external_essl3', 'GL_STENCIL_EXT', 'GL_EXT_texture_type_2_10_10_10_REV', 'GL_RELATIVE_SMALL_CCW_ARC_TO_NV', 'GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR', 'GL_PERFMON_RESULT_SIZE_AMD', 'GL_ETC1_SRGB8_NV', 'GL_SHADER_BINARY_VIV', 'GL_RELATIVE_CUBIC_CURVE_TO_NV', 'GL_FLOAT_MAT4x3_NV', 'GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD', 'GL_DEPTH_SAMPLES_NV', 'GL_PRIMITIVES_GENERATED_EXT', 'GL_DEPTH_STENCIL_OES', 'GL_IMAGE_BUFFER_EXT', 'GL_ATC_RGBA_EXPLICIT_ALPHA_AMD', 'GL_EXT_texture_buffer', 'GL_FLOAT_MAT2x3_NV', 'GL_FONT_HEIGHT_BIT_NV', 'GL_SRGB8_ALPHA8_EXT', 'GL_HSL_COLOR_KHR', 'GL_INT_10_10_10_2_OES', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES', 'GL_STACK_OVERFLOW_KHR', 'GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES', 'GL_MULTIPLY_KHR', 'GL_NV_fragment_coverage_to_color', 'GL_NV_fence', 'GL_PATH_STROKE_WIDTH_NV', 'GL_SMALL_CW_ARC_TO_NV', 'GL_DEBUG_SEVERITY_NOTIFICATION_KHR', 'GL_DST_OVER_NV', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR', 'GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT', 'GL_TEXTURE_BUFFER_SIZE_EXT', 'GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT', 'GL_TESS_GEN_VERTEX_ORDER_EXT', 'GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT', 'GL_COLOR_ATTACHMENT5_NV', 'GL_RGB_422_APPLE', 'GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG', 'GL_CONTEXT_ROBUST_ACCESS_EXT', 'GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV', 'GL_TEXTURE_OBJECT_VALID_QCOM', 'GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT', 'GL_PATH_DASH_ARRAY_COUNT_NV', 'GL_DRAW_BUFFER_EXT', 'GL_EXT_multisampled_compatibility', 'GL_RELATIVE_ROUNDED_RECT_NV', 'GL_MULTISAMPLE_EXT', 'GL_PATCHES_EXT', 'GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT', 'GL_TEXTURE_BINDING_EXTERNAL_OES', 'GL_PATH_GEN_COMPONENTS_NV', 'GL_EXT_unpack_subimage', 'GL_OVERLAY_KHR', 'GL_FRACTIONAL_ODD_OES', 'GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES', 'GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT', 'GL_MIN', 'GL_NV_sample_mask_override_coverage', 'GL_TEXTURE_WRAP_R_OES', 'GL_EXT_texture_storage', 'GL_TEXTURE_NUM_LEVELS_QCOM', 'GL_APPLE_color_buffer_packed_float', 'GL_ANGLE_texture_compression_dxt5', 'GL_QUADS_EXT', 'GL_PERFQUERY_WAIT_INTEL', 'GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT', 'GL_CIRCULAR_CW_ARC_TO_NV', 'GL_INNOCENT_CONTEXT_RESET_KHR', 'GL_IMG_texture_compression_pvrtc', 'GL_DIFFERENCE_NV', 'GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT', 'GL_RED_EXT', 'GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL', 'GL_COMPRESSED_RGB_S3TC_DXT1_EXT', 'GL_FJ_shader_binary_GCCSO', 'GL_EXT_disjoint_timer_query', 'GL_COLORDODGE_NV', 'GL_DST_OUT_NV', 'GL_NV_path_rendering_shared_edge', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES', 'GL_NV_conservative_raster', 'GL_COVERAGE_MODULATION_TABLE_SIZE_NV', 'GL_CUBIC_CURVE_TO_NV', 'GL_TEXTURE_VIEW_MIN_LEVEL_EXT', 'GL_ALPHA_TEST_QCOM', 'GL_XOR_NV', 'GL_SAMPLE_LOCATION_NV', 'GL_EXT_geometry_shader', 'GL_UNSIGNED_SHORT_8_8_REV_APPLE', 'GL_MAX_TESS_GEN_LEVEL_EXT', 'GL_MAX_FRAMEBUFFER_LAYERS_OES', 'GL_PATH_MODELVIEW_NV', 'GL_TEXTURE_BUFFER_OFFSET_EXT', 'GL_FONT_Y_MIN_BOUNDS_BIT_NV', 'GL_TEXTURE_WIDTH_QCOM', 'GL_FONT_UNAVAILABLE_NV', 'GL_FONT_UNITS_PER_EM_BIT_NV', 'GL_RG16_EXT', 'GL_OES_texture_npot', 'GL_RGB16F_EXT', 'GL_DUP_LAST_CUBIC_CURVE_TO_NV', 'GL_EXT_texture_sRGB_RG8', 'GL_DRAW_BUFFER13_EXT', 'GL_MULTISAMPLE_BUFFER_BIT2_QCOM', 'GL_IMAGE_CUBE_MAP_ARRAY_OES', 'GL_PATH_FORMAT_SVG_NV', 'GL_KHR_robust_buffer_access_behavior', 'GL_ROUNDED_RECT_NV', 'GL_LUMINANCE8_EXT', 'GL_LAYER_PROVOKING_VERTEX_OES', 'GL_FONT_DESCENDER_BIT_NV', 'GL_OES_tessellation_shader', 'GL_FRAMEBUFFER_DEFAULT_LAYERS_OES', 'GL_DEPTH_COMPONENT16_OES', 'GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT', 'GL_PATH_STROKE_COVER_MODE_NV', 'GL_OES_texture_buffer', 'GL_PROGRAM_PIPELINE_KHR', 'GL_EXT_post_depth_coverage', 'GL_GEOMETRY_SHADER_BIT_EXT', 'GL_ROUNDED_RECT2_NV', 'GL_COLORDODGE_KHR', 'GL_OES_get_program_binary', 'GL_SUPERSAMPLE_SCALE_X_NV', 'GL_MAX_SAMPLES_APPLE', 'GL_APPLE_framebuffer_multisample', 'GL_TRANSLATE_3D_NV', 'GL_TESS_GEN_VERTEX_ORDER_OES', 'GL_MULTISAMPLE_BUFFER_BIT7_QCOM', 'GL_OES_vertex_half_float', 'GL_FILL_RECTANGLE_NV', 'GL_FIRST_VERTEX_CONVENTION_EXT', 'GL_FENCE_STATUS_NV', 'GL_TEXTURE_IMAGE_VALID_QCOM', 'GL_RG16_SNORM_EXT', 'GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV', 'GL_DEPTH_BUFFER_BIT4_QCOM', 'GL_QCOM_alpha_test', 'GL_EXT_draw_instanced', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR', 'GL_ADJACENT_PAIRS_NV', 'GL_SGX_PROGRAM_BINARY_IMG', 'GL_SRC1_COLOR_EXT', 'GL_FONT_TARGET_UNAVAILABLE_NV', 'GL_COMPRESSED_RGBA_ASTC_8x8_KHR', 'GL_TESS_GEN_MODE_EXT', 'GL_RECT_NV', 'GL_DEBUG_OUTPUT_KHR', 'GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT', 'GL_PATH_DASH_CAPS_NV', 'GL_PATH_CLIENT_LENGTH_NV', 'GL_EXT_blend_func_extended', 'GL_PATCH_VERTICES_EXT', 'GL_FONT_NUM_GLYPH_INDICES_BIT_NV', 'GL_SGX_BINARY_IMG', 'GL_DRAW_BUFFER3_NV', 'GL_KHR_texture_compression_astc_hdr', 'GL_DEBUG_CALLBACK_USER_PARAM_KHR', 'GL_NV_read_depth_stencil', 'GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT', 'GL_SIGNALED_APPLE', 'GL_RGBA8_OES', 'GL_KHR_blend_equation_advanced', 'GL_MAX_SAMPLES_ANGLE', 'GL_OES_shader_image_atomic', 'GL_RELATIVE_CONIC_CURVE_TO_NV', 'GL_COLOR_ATTACHMENT7_NV', 'GL_EXT_geometry_point_size', 'GL_SLUMINANCE8_NV', 'GL_ANGLE_instanced_arrays', 'GL_TRIANGLE_STRIP_ADJACENCY_EXT', 'GL_TEXTURE_BUFFER_OES', 'GL_SHADER_OBJECT_EXT', 'GL_PATH_FILL_BOUNDING_BOX_NV', 'GL_LIGHTEN_NV', 'GL_EXT_draw_buffers_indexed', 'GL_SCREEN_NV', 'GL_PATH_INITIAL_DASH_CAP_NV', 'GL_KHR_no_error', 'GL_COLOR_ATTACHMENT11_NV', 'GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR', 'GL_RELATIVE_HORIZONTAL_LINE_TO_NV', 'GL_EXT_read_format_bgra', 'GL_DRAW_BUFFER10_EXT', 'GL_CIRCULAR_CCW_ARC_TO_NV', 'GL_MULTISAMPLE_BUFFER_BIT1_QCOM', 'GL_BUFFER_STORAGE_FLAGS_EXT', 'GL_FRACTIONAL_EVEN_EXT', 'GL_FONT_X_MIN_BOUNDS_BIT_NV', 'GL_TEXTURE_IMMUTABLE_FORMAT_EXT', 'GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT', 'GL_FRAGMENT_SHADER_BIT_EXT', 'GL_DRAW_FRAMEBUFFER_NV', 'GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR', 'GL_LINEARLIGHT_NV', 'GL_MOVE_TO_CONTINUES_NV', 'GL_MAX_3D_TEXTURE_SIZE_OES', 'GL_PROGRAM_SEPARABLE_EXT', 'GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES', 'GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR', 'GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT', 'GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV', 'GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM', 'GL_EXT_shader_io_blocks', 'GL_UNPACK_SKIP_PIXELS_EXT', 'GL_EXT_texture_filter_minmax', 'GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT', 'GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT', 'GL_NV_read_stencil', 'GL_PATH_MODELVIEW_STACK_DEPTH_NV', 'GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT', 'GL_BLEND_OVERLAP_NV', 'GL_COMPRESSED_RGBA_S3TC_DXT1_EXT', 'GL_COLOR_SAMPLES_NV', 'GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT', 'GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV', 'GL_NV_draw_buffers', 'GL_COLOR_ATTACHMENT0_EXT', 'GL_GEOMETRY_LINKED_VERTICES_OUT_OES', 'GL_SRC1_ALPHA_EXT', 'GL_PLUS_CLAMPED_NV', 'GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR', 'GL_SRGB_EXT', 'GL_NV_polygon_mode', 'GL_COMPRESSED_RGBA_ASTC_6x6_KHR', 'GL_FLOAT_MAT3x2_NV', 'GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT', 'GL_RGB565_OES', 'GL_RGB5_A1_OES', 'GL_SRGB8_NV', 'GL_MAP_INVALIDATE_BUFFER_BIT_EXT', 'GL_GEOMETRY_SHADER_INVOCATIONS_OES', 'GL_DUP_FIRST_CUBIC_CURVE_TO_NV', 'GL_DRAW_FRAMEBUFFER_BINDING_NV', 'GL_COMPRESSED_RGBA_ASTC_5x5x5_OES', 'GL_BINNING_CONTROL_HINT_QCOM', 'GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV', 'GL_COUNT_UP_NV', 'GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES', 'GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL', 'GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV', 'GL_VIRTUAL_PAGE_SIZE_INDEX_EXT', 'GL_EXT_blend_minmax', 'GL_CLIP_DISTANCE0_APPLE', 'GL_TRANSFORM_FEEDBACK', 'GL_SYNC_FLAGS_APPLE', 'GL_COLOR_ATTACHMENT1_NV', 'GL_COLOR_ATTACHMENT15_NV', 'GL_GPU_OPTIMIZED_QCOM', 'GL_NV_path_rendering', 'GL_OES_required_internalformat', 'GL_POLYGON_MODE_NV', 'GL_EXT_sRGB_write_control', 'GL_HSL_HUE_NV', 'GL_SAMPLER_3D_OES', 'GL_QCOM_driver_control', 'GL_IMAGE_BUFFER_OES', 'GL_COLOR_BUFFER_BIT3_QCOM', 'GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES', 'GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV', 'GL_OES_element_index_uint', 'GL_RENDERBUFFER_SAMPLES_IMG', 'GL_TESS_CONTROL_OUTPUT_VERTICES_EXT', 'GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG', 'GL_COMPRESSED_RGBA_ASTC_4x4x4_OES', 'GL_BUFFER_MAP_POINTER_OES', 'GL_MAX_SAMPLES_EXT', 'GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT', 'GL_MAX_PATCH_VERTICES_OES', 'GL_MOVE_TO_RESETS_NV', 'GL_HSL_HUE_KHR', 'GL_IMAGE_CUBE_MAP_ARRAY_EXT', 'GL_IMG_multisampled_render_to_texture', 'GL_BUFFER_MAPPED_OES', 'GL_COMPRESSED_RGBA_ASTC_8x6_KHR', 'GL_BLEND_ADVANCED_COHERENT_KHR', 'GL_TEXTURE_SRGB_DECODE_EXT', 'GL_EXCLUSION_KHR', 'GL_HALF_FLOAT_OES', 'GL_MIN_SAMPLE_SHADING_VALUE_OES', 'GL_COMPRESSED_RGBA_ASTC_12x10_KHR', 'GL_SYSTEM_FONT_NAME_NV', 'GL_APPLE_copy_texture_levels', 'GL_OES_texture_stencil8', 'GL_3DC_X_AMD', 'GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES', 'GL_LINE_TO_NV', 'GL_NV_read_depth', 'GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT', 'GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL', 'GL_FILL_NV', 'GL_FRACTIONAL_ODD_EXT', 'GL_OES_stencil4', 'GL_OES_stencil1', 'GL_GUILTY_CONTEXT_RESET_EXT', 'GL_OES_texture_3D', 'GL_RELATIVE_ARC_TO_NV', 'GL_UNSIGNALED_APPLE', 'GL_DEPTH_BUFFER_BIT3_QCOM', 'GL_VIV_shader_binary', 'GL_TESS_CONTROL_SHADER_BIT_OES', 'GL_SMALL_CCW_ARC_TO_NV', 'GL_COLOR_ATTACHMENT6_EXT', 'GL_DRAW_BUFFER4_EXT', 'GL_DMP_PROGRAM_BINARY_DMP', 'GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT', 'GL_DEBUG_TYPE_ERROR_KHR', 'GL_COLOR_ATTACHMENT9_NV', 'GL_CIRCULAR_TANGENT_ARC_TO_NV', 'GL_UNSIGNED_INT_SAMPLER_BUFFER_OES', 'GL_STENCIL_BUFFER_BIT1_QCOM', 'GL_COUNTER_TYPE_AMD', 'GL_READ_FRAMEBUFFER_APPLE', 'GL_COLOR_ATTACHMENT2_EXT', 'GL_MAX_PATCH_VERTICES_EXT', 'GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV', 'GL_HORIZONTAL_LINE_TO_NV', 'GL_ALPHA8_OES', 'GL_COMPRESSED_RGBA_ASTC_12x12_KHR', 'GL_NV_sRGB_formats', 'GL_COMPRESSED_RGBA_ASTC_10x8_KHR', 'GL_RESTART_PATH_NV', 'GL_COLOR_ATTACHMENT7_EXT', 'GL_PATH_OBJECT_BOUNDING_BOX_NV', 'GL_SYNC_CONDITION_APPLE', 'GL_FONT_ASCENDER_BIT_NV', 'GL_POLYGON_OFFSET_POINT_NV', 'GL_APPLE_texture_packed_float', 'GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT', 'GL_RG_EXT', 'GL_MAX_MULTIVIEW_BUFFERS_EXT', 'GL_FRACTIONAL_EVEN_OES', 'GL_GEOMETRY_LINKED_INPUT_TYPE_EXT', 'GL_DEPTH_EXT', 'GL_COLOR_EXT', 'GL_PATH_COORD_COUNT_NV', 'GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES', 'GL_OES_texture_half_float_linear', 'GL_RG8_SNORM', 'GL_SAMPLER_BUFFER_EXT', 'GL_PROGRAM_PIPELINE_OBJECT_EXT', 'GL_TEXTURE_2D_MULTISAMPLE_ARRAY', 'GL_REFERENCED_BY_GEOMETRY_SHADER_OES', 'GL_TESS_EVALUATION_SHADER_BIT_EXT', 'GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES', 'GL_EXT_color_buffer_half_float', 'GL_NV_viewport_array2', 'GL_COLOR_ATTACHMENT8_EXT', 'GL_LOSE_CONTEXT_ON_RESET_KHR', 'GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE', 'GL_COVERAGE_SAMPLES_NV', 'GL_ARC_TO_NV', 'GL_DMP_program_binary', 'GL_COMPRESSED_RGBA_ASTC_3x3x3_OES', 'GL_VERTICAL_LINE_TO_NV', 'GL_COLOR_ATTACHMENT10_EXT', 'GL_READ_FRAMEBUFFER_BINDING_APPLE', 'GL_STATE_RESTORE', 'GL_SKIP_DECODE_EXT', 'GL_DEBUG_SOURCE_APPLICATION_KHR', 'GL_QUADRATIC_CURVE_TO_NV', 'GL_CPU_OPTIMIZED_QCOM', 'GL_R16_SNORM_EXT', 'GL_MAX_LABEL_LENGTH_KHR', 'GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV', 'GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL', 'GL_BOLD_BIT_NV', 'GL_SYNC_FENCE_APPLE', 'GL_TEXTURE_BORDER_COLOR_OES', 'GL_PATH_TERMINAL_END_CAP_NV', 'GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE', 'GL_PATH_MODELVIEW_MATRIX_NV', 'GL_COMPARE_REF_TO_TEXTURE_EXT', 'GL_PROGRAMMABLE_SAMPLE_LOCATION_NV', 'GL_DEPTH_BUFFER_BIT6_QCOM', 'GL_NV_draw_instanced', 'GL_PERFQUERY_GLOBAL_CONTEXT_INTEL', 'GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES', 'GL_R8_EXT', 'GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES', 'GL_TEXTURE_CUBE_MAP_ARRAY_OES', 'GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV', 'GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES', 'GL_PATCHES_OES', 'GL_OES_fbo_render_mipmap', 'GL_DRAW_BUFFER6_EXT', 'GL_TEXTURE_TARGET_QCOM', 'GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT', 'GL_VIRTUAL_PAGE_SIZE_Z_EXT', 'GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL', 'GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV', 'GL_RG8_EXT', 'GL_NV_fragment_shader_interlock', 'GL_EXT_buffer_storage', 'GL_FRAMEBUFFER_UNDEFINED_OES', 'GL_STENCIL_BUFFER_BIT2_QCOM', 'GL_RG32F_EXT', 'GL_PATH_FILL_MASK_NV', 'GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT', 'GL_ONE_MINUS_SRC1_COLOR_EXT', 'GL_TEXTURE_VIEW_MIN_LEVEL_OES', 'GL_NV_framebuffer_mixed_samples', 'GL_MAX_EXT', 'GL_TESS_EVALUATION_SHADER_EXT', 'GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT', 'GL_FRAMEBUFFER_SRGB_EXT', 'GL_GEOMETRY_SHADER_BIT_OES', 'GL_COLOR_BUFFER_BIT7_QCOM', 'GL_EXT_raster_multisample', 'GL_CLIP_DISTANCE7_APPLE', 'GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES', 'GL_VIVIDLIGHT_NV', 'GL_VERTEX_ARRAY_BINDING_OES', 'GL_DRAW_BUFFER14_NV', 'GL_NV_geometry_shader_passthrough', 'GL_INTEL_framebuffer_CMAA', 'GL_LUMINANCE_ALPHA16F_EXT', 'GL_EXT_texture_border_clamp', 'GL_PROGRAM_OBJECT_EXT', 'GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES', 'GL_EXT_draw_buffers', 'GL_PATH_FORMAT_PS_NV', 'GL_PRIMITIVE_BOUNDING_BOX_OES', 'GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG', 'GL_SHARED_EDGE_NV', 'GL_STANDARD_FONT_NAME_NV', 'GL_NUM_PROGRAM_BINARY_FORMATS_OES', 'GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE', 'GL_BLUE_NV', 'GL_FONT_Y_MAX_BOUNDS_BIT_NV', 'GL_MAX_CLIP_DISTANCES_APPLE', 'GL_OES_texture_view', 'GL_PALETTE4_RGBA4_OES', 'GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT', 'GL_CONVEX_HULL_NV', 'GL_FIRST_TO_REST_NV', 'GL_COVERAGE_AUTOMATIC_NV', 'GL_RELATIVE_VERTICAL_LINE_TO_NV', 'GL_SR8_EXT', 'GL_EXT_tessellation_point_size', 'GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR', 'GL_USE_MISSING_GLYPH_NV', 'GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT', 'GL_GLYPH_HAS_KERNING_BIT_NV', 'GL_PATCH_VERTICES_OES', 'GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL', 'GL_EXT_base_instance', 'GL_EXT_texture_view', 'GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV', 'GL_NUM_VIRTUAL_PAGE_SIZES_EXT', 'GL_SAMPLE_SHADING_OES', 'GL_PLUS_DARKER_NV', 'GL_TEXTURE_2D_MULTISAMPLE', 'GL_HSL_LUMINOSITY_KHR', 'GL_ITALIC_BIT_NV', 'GL_ANGLE_pack_reverse_row_order', 'GL_VIRTUAL_PAGE_SIZE_X_EXT', 'GL_DEPTH_BUFFER_BIT2_QCOM', 'GL_TRIANGULAR_NV', 'GL_TESS_GEN_SPACING_OES', 'GL_GUILTY_CONTEXT_RESET_KHR', 'GL_R8_SNORM', 'GL_COMPRESSED_RGBA_ASTC_8x5_KHR', 'GL_QUERY_KHR', 'GL_QCOM_writeonly_rendering', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES', 'GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES', 'GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT', 'GL_DST_IN_NV', 'GL_INTEL_performance_query', 'GL_COMPRESSED_RGBA_ASTC_6x6x6_OES', 'GL_RENDERBUFFER_SAMPLES_EXT', 'GL_COLORBURN_NV', 'GL_TEXTURE_BUFFER_EXT', 'GL_PALETTE8_RGB5_A1_OES', 'GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES', 'GL_GEOMETRY_SHADER_OES', 'GL_STENCIL_BUFFER_BIT0_QCOM', 'GL_PALETTE8_RGBA8_OES', 'GL_EXT_sparse_texture', 'GL_MAX_COLOR_ATTACHMENTS_EXT', 'GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES', 'GL_UNSIGNED_INT_IMAGE_BUFFER_EXT', 'GL_SYNC_STATUS_APPLE', 'GL_INVERT_OVG_NV', 'GL_VERTEX_SHADER_BIT_EXT', 'GL_COMPRESSED_RGBA_ASTC_5x4x4_OES', 'GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG', 'GL_RESET_NOTIFICATION_STRATEGY_EXT', 'GL_UNSIGNED_INT_24_8_OES', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR', 'GL_FRAGMENT_INPUT_NV', 'GL_COMPRESSED_RGBA_ASTC_10x5_KHR', 'GL_OES_texture_border_clamp', 'GL_RGB10_A2_EXT', 'GL_QUERY_COUNTER_BITS_EXT', 'GL_DEPTH_BUFFER_BIT1_QCOM', 'GL_MAX_COLOR_ATTACHMENTS_NV', 'GL_TEXTURE_COMPARE_MODE_EXT', 'GL_TEXTURE_SAMPLES_IMG', 'GL_STANDARD_FONT_FORMAT_NV', 'GL_PATH_TERMINAL_DASH_CAP_NV', 'GL_HSL_LUMINOSITY_NV', 'GL_LUMINANCE8_ALPHA8_OES', 'GL_SRC_NV', 'GL_UNSIGNED_INT_10_10_10_2_OES', 'GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES', 'GL_COMPRESSED_RGBA_S3TC_DXT3_EXT', 'GL_READ_FRAMEBUFFER_BINDING_ANGLE', 'GL_DEPTH_COMPONENT16_NONLINEAR_NV', 'GL_RGB10_EXT', 'GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES', 'GL_IMG_shader_binary', 'GL_PROGRAM_KHR', 'GL_PATH_DASH_OFFSET_NV', 'GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT', 'GL_SLUMINANCE_NV', 'GL_EXT_draw_elements_base_vertex', 'GL_OES_depth32', 'GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT', 'GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV', 'GL_STENCIL_INDEX4_OES', 'GL_SRG8_EXT', 'GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT', 'GL_COVERAGE_BUFFERS_NV', 'GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT', 'GL_EXT_multi_draw_indirect', 'GL_ARM_shader_framebuffer_fetch', 'GL_UNSIGNED_INT_5_9_9_9_REV_APPLE', 'GL_CLAMP_TO_BORDER_NV', 'GL_LARGE_CCW_ARC_TO_NV', 'GL_OES_texture_storage_multisample_2d_array', 'GL_WRITEONLY_RENDERING_QCOM', 'GL_COMPRESSED_RGBA_ASTC_10x6_KHR', 'GL_COLOR_ATTACHMENT12_EXT', 'GL_SAMPLER_CUBE_MAP_ARRAY_EXT', 'GL_OES_vertex_type_10_10_10_2', 'GL_COVERAGE_COMPONENT4_NV', 'GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES', 'GL_EXT_texture_sRGB_decode', 'GL_NV_texture_npot_2D_mipmap', 'GL_DRAW_BUFFER1_NV', 'GL_MAX_DEBUG_MESSAGE_LENGTH_KHR', 'GL_SRC_IN_NV', 'GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES', 'GL_PATH_PROJECTION_NV', 'GL_MAX_VIEWPORTS_NV', 'GL_DEBUG_CALLBACK_FUNCTION_KHR', 'GL_COLOR_BUFFER_BIT5_QCOM', 'GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES', 'GL_EXT_debug_label', 'GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES', 'GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES', 'GL_NV_sample_locations', 'GL_SAMPLER_EXTERNAL_OES', 'GL_RELATIVE_ROUNDED_RECT8_NV', 'GL_UNCORRELATED_NV', 'GL_NV_internalformat_sample_query', 'GL_STENCIL_BUFFER_BIT6_QCOM', 'GL_PATH_FILL_COVER_MODE_NV', 'GL_DRAW_BUFFER12_EXT', 'GL_UNPACK_ROW_LENGTH_EXT', 'GL_QUERY_NO_WAIT_NV', 'GL_RED_NV', 'GL_COLOR_ATTACHMENT3_NV', 'GL_OES_gpu_shader5', 'GL_DRAW_BUFFER15_EXT', 'GL_FIRST_VERTEX_CONVENTION_OES', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES', 'GL_RGB9_E5_APPLE', 'GL_DRAW_FRAMEBUFFER_ANGLE', 'GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES', 'GL_COVERAGE_BUFFER_BIT_NV', 'GL_LAST_VERTEX_CONVENTION_EXT', 'GL_LINES_ADJACENCY_EXT', 'GL_PALETTE4_RGB8_OES', 'GL_TRIANGLES_ADJACENCY_OES', 'GL_REFERENCED_BY_GEOMETRY_SHADER_EXT', 'GL_CLIP_DISTANCE6_APPLE', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES', 'GL_DRAW_BUFFER4_NV', 'GL_MAX_TEXTURE_BUFFER_SIZE_EXT', 'GL_OES_mapbuffer', 'GL_EXT_texture_cube_map_array', 'GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES', 'GL_COLOR_ATTACHMENT13_NV', 'GL_COUNT_DOWN_NV', 'GL_CLIP_DISTANCE3_APPLE', 'GL_EXT_tessellation_shader', 'GL_COMPRESSED_RGBA_S3TC_DXT5_EXT', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES', 'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES', 'GL_DARKEN_NV', 'GL_AFFINE_3D_NV', 'GL_EXT_discard_framebuffer', 'GL_RELATIVE_LINE_TO_NV', 'GL_LAYER_PROVOKING_VERTEX_EXT', 'GL_SLUMINANCE8_ALPHA8_NV', 'GL_RGBA16F_EXT', 'GL_QUERY_RESULT_AVAILABLE_EXT', 'GL_RGBA4_OES', 'GL_OES_draw_elements_base_vertex', 'GL_AFFINE_2D_NV', 'GL_OES_texture_cube_map_array', 'GL_GLYPH_HEIGHT_BIT_NV', 'GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT', 'GL_PROGRAM_BINARY_ANGLE', 'GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES', 'GL_SHADER_PIXEL_LOCAL_STORAGE_EXT', 'GL_OES_sample_shading', 'GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV', 'GL_BUFFER_OBJECT_EXT', 'GL_TEXTURE_BUFFER_BINDING_EXT', 'GL_MAP_WRITE_BIT_EXT', 'GL_DST_ATOP_NV', 'GL_PATH_DASH_OFFSET_RESET_NV', 'GL_COLOR_BUFFER_BIT6_QCOM', 'GL_STENCIL_BUFFER_BIT7_QCOM', 'GL_WRITE_ONLY_OES', 'GL_APPLE_sync', 'GL_RELATIVE_ROUNDED_RECT4_NV', 'GL_PRIMITIVES_GENERATED_OES', 'GL_TRANSLATE_X_NV', 'GL_ARM_rgba8', 'GL_COMPRESSED_RGBA_ASTC_6x5x5_OES', 'GL_MULTISAMPLE_BUFFER_BIT4_QCOM', 'GL_HARDMIX_NV', 'GL_FRAGMENT_COVERAGE_COLOR_NV', 'GL_ALL_COMPLETED_NV', 'GL_TEXTURE_BINDING_3D_OES', 'GL_COLOR_BUFFER_BIT2_QCOM', 'GL_MAP_UNSYNCHRONIZED_BIT_EXT', 'GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE', 'GL_TEXTURE_BINDING_BUFFER_EXT', 'GL_BGRA8_EXT', 'GL_EXT_texture_sRGB_R8', 'GL_RELATIVE_RECT_NV', 'GL_SRC_ATOP_NV', 'GL_RGB_RAW_422_APPLE', 'GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG', 'GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT', 'GL_READ_FRAMEBUFFER_ANGLE', 'GL_PERFQUERY_DONOT_FLUSH_INTEL', 'GL_NV_instanced_arrays', 'GL_TEXTURE_CUBE_MAP_ARRAY_EXT', 'GL_CLIP_DISTANCE2_APPLE', 'GL_UNPACK_SKIP_ROWS_EXT', 'GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT', 'GL_PATH_JOIN_STYLE_NV', 'GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT', 'GL_GLYPH_VERTICAL_BEARING_X_BIT_NV', 'GL_MULTISAMPLE_BUFFER_BIT0_QCOM', 'GL_LOCATION_INDEX_EXT', 'GL_FETCH_PER_SAMPLE_ARM', 'GL_COVERAGE_ALL_FRAGMENTS_NV', 'GL_TEXTURE_EXTERNAL_OES', 'GL_COMPRESSED_SRGB_S3TC_DXT1_NV', 'GL_TRANSPOSE_AFFINE_3D_NV', 'GL_READ_BUFFER_EXT', 'GL_ACCUM_ADJACENT_PAIRS_NV', 'GL_OVERLAY_NV', 'GL_QCOM_perfmon_global_mode', 'GL_GEOMETRY_LINKED_VERTICES_OUT_EXT', 'GL_SRC_ALPHA_SATURATE_EXT', 'GL_ALPHA_TEST_REF_QCOM', 'GL_KHR_blend_equation_advanced_coherent', 'GL_DARKEN_KHR', 'GL_EXT_instanced_arrays', 'GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL', 'GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV', 'GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV', 'GL_SRGB_ALPHA_EXT', 'GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV', 'GL_OES_texture_compression_astc', 'GL_TEXTURE_HEIGHT_QCOM', 'GL_OES_texture_half_float', 'GL_FLOAT_MAT4x2_NV', 'GL_OES_rgb8_rgba8', 'GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV', 'GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT', 'GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES', 'GL_PLUS_CLAMPED_ALPHA_NV', 'GL_UTF16_NV', 'GL_MAP_READ_BIT', 'GL_ANGLE_translated_shader_source', 'GL_DRAW_BUFFER10_NV', 'GL_NV_fill_rectangle', 'GL_DRAW_BUFFER9_EXT', 'GL_EXT_texture_format_BGRA8888', 'GL_PALETTE4_RGBA8_OES', 'GL_BGRA_IMG', 'GL_PATH_FILL_MODE_NV', 'GL_DEPTH_COMPONENT24_OES', 'GL_RASTER_SAMPLES_EXT', 'GL_DEBUG_TYPE_PERFORMANCE_KHR', 'GL_RGBA32F_EXT', 'GL_AMD_program_binary_Z400', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR', 'GL_TEXTURE_BUFFER_OFFSET_OES', 'GL_DRAW_BUFFER7_NV', 'GL_CURRENT_QUERY_EXT', 'GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL', 'GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR', 'GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES', 'GL_IMG_read_format', 'GL_DRAW_FRAMEBUFFER_BINDING_APPLE', 'GL_TEXTURE_VIEW_NUM_LEVELS_EXT', 'GL_DRAW_BUFFER5_NV', 'GL_OES_compressed_ETC1_RGB8_sub_texture', 'GL_COLOR_ATTACHMENT5_EXT', 'GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES', 'GL_NV_coverage_sample', 'GL_EXT_gpu_shader5', 'GL_OES_shader_io_blocks', 'GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV', 'GL_UNDEFINED_VERTEX_OES', 'GL_EXT_shader_texture_lod', 'GL_UNKNOWN_CONTEXT_RESET_EXT', 'GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT', 'GL_DEPTH_BUFFER_BIT7_QCOM', 'GL_PERFQUERY_SINGLE_CONTEXT_INTEL', 'GL_NV_read_buffer_front', 'GL_SQUARE_NV', 'GL_COMPRESSED_RGBA_ASTC_5x5_KHR', 'GL_SYNC_FLUSH_COMMANDS_BIT_APPLE', 'GL_COPY_WRITE_BUFFER_NV', 'GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV', 'GL_SHADER_KHR', 'GL_NUM_SPARSE_LEVELS_EXT', 'GL_MAP_COHERENT_BIT_EXT', 'GL_PATH_STROKE_BOUNDING_BOX_NV', 'GL_ANDROID_extension_pack_es31a', 'GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT', 'GL_COLOR_ATTACHMENT10_NV', 'GL_ISOLINES_OES', 'GL_RGB16_SNORM_EXT', 'GL_DRAW_BUFFER12_NV', 'GL_DEPTH_BUFFER_BIT0_QCOM', 'GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV', 'GL_INT_IMAGE_BUFFER_OES', 'GL_ROUNDED_RECT8_NV', 'GL_DRAW_BUFFER2_NV', 'GL_DRAW_BUFFER5_EXT', 'GL_SOFTLIGHT_KHR', 'GL_PERFQUERY_FLUSH_INTEL', 'GL_APPLE_clip_distance', 'GL_MAX_SERVER_WAIT_TIMEOUT_APPLE', 'GL_GEOMETRY_SHADER_INVOCATIONS_EXT', 'GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES', 'GL_TEXTURE_VIEW_MIN_LAYER_EXT', 'GL_CONSERVATIVE_RASTERIZATION_NV', 'GL_SMAPHS_PROGRAM_BINARY_DMP', 'GL_ALPHA32F_EXT', 'GL_BUFFER_ACCESS_OES', 'GL_KHR_texture_compression_astc_ldr', 'GL_DEBUG_LOGGED_MESSAGES_KHR', 'GL_CONDITION_SATISFIED_APPLE', 'GL_OES_geometry_shader', 'GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT', 'GL_EXT_pvrtc_sRGB', 'GL_RELATIVE_LARGE_CCW_ARC_TO_NV', 'GL_QCOM_extended_get', 'GL_NV_blend_equation_advanced_coherent', 'GL_TESS_GEN_POINT_MODE_EXT', 'GL_CLIP_DISTANCE1_APPLE', 'GL_TESS_EVALUATION_SHADER_BIT_OES', 'GL_READ_FRAMEBUFFER_BINDING_NV', 'GL_DEBUG_SOURCE_OTHER_KHR', 'GL_SAMPLER_CUBE_MAP_ARRAY_OES', 'GL_DEPTH24_STENCIL8_OES', 'GL_COPY_READ_BUFFER_NV', 'GL_DRAW_FRAMEBUFFER_BINDING_ANGLE', 'GL_MAX_TESS_PATCH_COMPONENTS_OES', 'GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT', 'GL_OES_texture_float', 'GL_CONFORMANT_NV', 'GL_DEBUG_TYPE_MARKER_KHR', 'GL_MAX_DEBUG_LOGGED_MESSAGES_KHR', 'GL_CLOSE_PATH_NV', 'GL_PALETTE4_RGB5_A1_OES', 'GL_TRIANGLE_STRIP_ADJACENCY_OES', 'GL_NV_shadow_samplers_cube', 'GL_HSL_COLOR_NV', 'GL_EXT_debug_marker', 'GL_LUMINANCE8_ALPHA8_EXT', 'GL_UNSIGNED_INT64_AMD', 'GL_ALPHA_TEST_FUNC_QCOM', 'GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT', 'GL_NV_shader_noperspective_interpolation', 'GL_MULTIVIEW_EXT', 'GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL', 'GL_TEXTURE_BUFFER_SIZE_OES', 'GL_MALI_PROGRAM_BINARY_ARM', 'GL_PERFMON_RESULT_AMD', 'GL_DEBUG_SEVERITY_HIGH_KHR', 'GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES', 'GL_OES_tessellation_point_size', 'GL_PATH_STENCIL_REF_NV', 'GL_OES_depth_texture', 'GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED', 'GL_SRC_OVER_NV', 'GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES', 'GL_PACK_REVERSE_ROW_ORDER_ANGLE', 'GL_SAMPLER_BUFFER_OES', 'GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES', 'GL_OES_surfaceless_context', 'GL_READ_BUFFER_NV', 'GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT', 'GL_COLOR_ATTACHMENT4_NV', 'GL_MINUS_CLAMPED_NV', 'GL_EXT_shader_framebuffer_fetch', 'GL_FONT_UNDERLINE_POSITION_BIT_NV', 'GL_DMP_shader_binary', 'GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES', 'GL_NV_texture_compression_s3tc_update', 'GL_MULTIPLY_NV', 'GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT', 'GL_ANGLE_program_binary', 'GL_TEXTURE_3D', 'GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT', 'GL_MAP_READ_BIT_EXT', 'GL_ANGLE_texture_compression_dxt3', 'GL_DEBUG_SOURCE_API_KHR', 'GL_CLAMP_TO_BORDER_EXT', 'GL_DEBUG_SOURCE_SHADER_COMPILER_KHR', 'GL_TEXTURE_COMPARE_FUNC_EXT', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR', 'GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES', 'GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES', 'GL_PINLIGHT_NV', 'GL_LOSE_CONTEXT_ON_RESET_EXT', 'GL_QUERY_WAIT_NV', 'GL_COLOR_ATTACHMENT3_EXT', 'GL_LUMINANCE8_OES', 'GL_APPLE_texture_max_level', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES', 'GL_PATH_COVER_DEPTH_FUNC_NV', 'GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT', 'GL_SCREEN_KHR', 'GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV', 'GL_EXT_texture_compression_dxt1', 'GL_MIN_EXT', 'GL_TEXTURE_INTERNAL_FORMAT_QCOM', 'GL_LAST_VERTEX_CONVENTION_OES', 'GL_RENDERBUFFER_SAMPLES_ANGLE', 'GL_NV_framebuffer_multisample', 'GL_CONTEXT_FLAG_DEBUG_BIT_KHR', 'GL_COLOR_ATTACHMENT14_EXT', 'GL_COMPRESSED_RGBA_ASTC_5x5x4_OES', 'GL_MAX_RASTER_SAMPLES_EXT', 'GL_OES_EGL_image', 'GL_MULTISAMPLES_NV', 'GL_LINE_STRIP_ADJACENCY_OES', 'GL_UNSIGNED_SHORT_8_8_APPLE', 'GL_MITER_TRUNCATE_NV', 'GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT', 'GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT', 'GL_COLOR_ATTACHMENT8_NV', 'GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES', 'GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR', 'GL_TIMEOUT_IGNORED_APPLE', 'GL_FRAMEBUFFER_ATTACHMENT_ANGLE', 'GL_APPLE_rgb_422', 'GL_TESS_GEN_POINT_MODE_OES', 'GL_MAX_SPARSE_TEXTURE_SIZE_EXT', 'GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT', 'GL_HSL_SATURATION_NV', 'GL_NV_blend_equation_advanced', 'GL_PLUS_NV', 'GL_IS_PER_PATCH_OES', 'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR', 'GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV', 'GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG', 'GL_TESS_GEN_MODE_OES', '__gl2ext_h_', 'GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT', 'GL_FONT_GLYPHS_AVAILABLE_NV', 'GL_ETC1_RGB8_OES', 'GL_WAIT_FAILED_APPLE', 'GL_EXT_texture_filter_anisotropic', 'GL_PERFMON_RESULT_AVAILABLE_AMD', 'GL_PROGRAM_BINARY_LENGTH_OES', 'GL_NO_RESET_NOTIFICATION_EXT', 'GL_OES_depth24', 'GL_INT_SAMPLER_BUFFER_EXT', 'GL_MITER_REVERT_NV', 'GL_COVERAGE_ATTACHMENT_NV', 'GL_DEBUG_SEVERITY_MEDIUM_KHR', 'GL_TEXTURE_2D_ARRAY', 'GL_MAX_VIEWS_OVR', 'GL_STENCIL_SAMPLES_NV', 'GL_DRAW_BUFFER1_EXT', 'GL_MULTISAMPLE_BUFFER_BIT3_QCOM', 'GL_COLOR_BUFFER_BIT1_QCOM', 'GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV', 'GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT', 'GL_SAMPLER_CUBE_SHADOW_NV', 'GL_RGB16_EXT', 'GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG', 'GL_EXT_render_snorm', 'GL_DRAW_BUFFER0_NV', 'GL_DEBUG_TYPE_POP_GROUP_KHR', 'GL_EXT_map_buffer_range', 'GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT', 'GL_SOFTLIGHT_NV', 'GL_GPU_DISJOINT_EXT', 'GL_TEXTURE_USAGE_ANGLE', 'GL_EXT_float_blend', 'GL_DRAW_BUFFER3_EXT', 'GL_VIEWPORT_BOUNDS_RANGE_NV', 'GL_ARM_shader_framebuffer_fetch_depth_stencil', 'GL_FONT_UNDERLINE_THICKNESS_BIT_NV', 'GL_TEXTURE_BUFFER_BINDING_OES', 'GL_TIMESTAMP_EXT', 'GL_MALI_SHADER_BINARY_ARM', 'GL_OES_EGL_image_external', 'GL_ALREADY_SIGNALED_APPLE', 'GL_COLOR_ATTACHMENT2_NV', 'GL_APPLE_texture_format_BGRA8888', 'GL_MAX', 'GL_TEXTURE_SPARSE_EXT', 'GL_CLIENT_STORAGE_BIT_EXT', 'GL_TEXTURE_BINDING_BUFFER_OES', 'GL_NV_shadow_samplers_array', 'GL_INVERT_RGB_NV', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR', 'GL_LIGHTEN_KHR', 'GL_NV_bindless_texture', 'GL_DRAW_FRAMEBUFFER_APPLE', 'GL_ARM_mali_shader_binary', 'GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES', 'GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL', 'GL_COMPRESSED_RGBA_ASTC_4x3x3_OES', 'GL_MAP_INVALIDATE_RANGE_BIT_EXT', 'GL_PATH_MITER_LIMIT_NV', 'GL_LINE_NV', 'GL_QUERY_BY_REGION_WAIT_NV', 'GL_TESS_CONTROL_SHADER_OES', 'GL_EXT_texture_rg', 'GL_HSL_SATURATION_KHR', 'GL_GCCSO_SHADER_BINARY_FJ', 'GL_STENCIL_BUFFER_BIT4_QCOM', 'GL_DEBUG_TYPE_PORTABILITY_KHR', 'GL_TEXTURE_MAX_ANISOTROPY_EXT', 'GL_EFFECTIVE_RASTER_SAMPLES_EXT', 'GL_COLOR_ATTACHMENT0_NV', 'GL_ONE_MINUS_SRC1_ALPHA_EXT', 'GL_DEBUG_SEVERITY_LOW_KHR', 'GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT', 'GL_OES_primitive_bounding_box', 'GL_LUMINANCE16F_EXT', 'GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES', 'GL_INT_IMAGE_CUBE_MAP_ARRAY_OES', 'GL_EXCLUSION_NV', 'GL_INNOCENT_CONTEXT_RESET_EXT', 'GL_CONTEXT_ROBUST_ACCESS_KHR', 'GL_PATH_STROKE_MASK_NV', 'GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES', 'GL_TEXTURE_MAX_LEVEL_APPLE', 'GL_DRAW_BUFFER2_EXT', 'GL_AMD_compressed_ATC_texture', 'GL_PATH_GEN_COEFF_NV', 'GL_ROUNDED_RECT4_NV', 'GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT', 'GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES', 'GL_INT_IMAGE_BUFFER_EXT', 'GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT', 'GL_ALPHA16F_EXT', 'GL_COMPRESSED_RGBA_ASTC_5x4_KHR', 'GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES', 'GL_HARDLIGHT_NV', 'GL_RG16F_EXT', 'GL_DRAW_BUFFER11_EXT', 'GL_TRANSLATE_2D_NV', 'GL_BLEND_ADVANCED_COHERENT_NV', 'GL_KHR_context_flush_control', 'GL_SAMPLER', 'GL_LINEARBURN_NV', 'GLchar', 'GLenum', 'GLboolean', 'GLbitfield', 'GLbyte', 'GLshort', 'GLint', 'GLint64', 'GLsizei', 'GLubyte', 'GLushort', 'GLuint', 'GLfloat', 'GLclampf', 'GLfixed', 'GLintptr', 'GLsizeiptr', 'GLclampx', 'void', 'GLvoid', 'GLsync']